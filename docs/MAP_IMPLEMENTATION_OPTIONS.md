# Technische Implementierungsoptionen: Interaktive Karte in Tkinter

**Datum:** 10. Oktober 2025  
**Kontext:** IMMI API Map-Visualisierung ohne Browser-Komponenten

---

## üéØ Anforderung

Interaktive Kartendarstellung von 9,160 Geodaten-Punkten (BImSchG + WKA) direkt in Tkinter Canvas ohne HTML/JavaScript-Abh√§ngigkeiten.

---

## üõ†Ô∏è Technische Optionen

### Option 1: **Tkintermapview** (EMPFOHLUNG ‚úÖ)

**Library:** `tkintermapview` (Pure Python, aktiv entwickelt)

```bash
pip install tkintermapview
```

**Vorteile:**
- ‚úÖ **Native Tkinter-Integration** (kein Browser-Widget)
- ‚úÖ **OpenStreetMap Tiles** automatisch geladen
- ‚úÖ **Marker-Support** mit Custom Icons
- ‚úÖ **Polygone & Polylinien** f√ºr Regionen
- ‚úÖ **Click-Events** auf Marker
- ‚úÖ **Zoom & Pan** mit Maus/Touchpad
- ‚úÖ **Offline-Caching** von Map-Tiles
- ‚úÖ **Leichtgewichtig** (~50 KB)
- ‚úÖ **Aktiv maintained** (letztes Update: 2024)

**Nachteile:**
- ‚ö†Ô∏è Performance bei >1000 Markern (wird langsam)
- ‚ö†Ô∏è Kein Marker-Clustering eingebaut
- ‚ö†Ô∏è Keine Heatmap-Unterst√ºtzung

**Code-Beispiel:**

```python
import tkinter as tk
from tkintermapview import TkinterMapView

class IMMIMapWidget(tk.Frame):
    def __init__(self, parent, backend_url="http://localhost:5000"):
        super().__init__(parent)
        self.backend_url = backend_url
        
        # Map Widget erstellen
        self.map_widget = TkinterMapView(self, width=800, height=600)
        self.map_widget.pack(fill="both", expand=True)
        
        # Brandenburg-Zentrum setzen
        self.map_widget.set_position(52.45, 13.37)  # Lat, Lon
        self.map_widget.set_zoom(8)
        
        # Marker laden
        self.load_markers()
    
    def load_markers(self):
        """L√§dt BImSchG + WKA Marker von IMMI API"""
        import requests
        
        # BImSchG-Anlagen laden
        response = requests.get(f"{self.backend_url}/api/immi/markers/bimschg?limit=1000")
        if response.status_code == 200:
            markers = response.json()
            for marker in markers:
                self.add_marker(
                    marker['lat'], 
                    marker['lon'], 
                    text=marker['name'],
                    marker_color='red' if 'Feuerung' in marker['category'] else 'blue'
                )
    
    def add_marker(self, lat, lon, text, marker_color='red'):
        """F√ºgt Marker zur Karte hinzu"""
        marker = self.map_widget.set_marker(
            lat, lon, 
            text=text,
            marker_color_circle=marker_color,
            marker_color_outside=marker_color
        )
        marker.command = lambda: self.on_marker_click(text)
        return marker
    
    def on_marker_click(self, name):
        """Marker wurde geklickt"""
        print(f"Marker clicked: {name}")
        # Hier: Info-Dialog √∂ffnen
```

**Performance-Optimierung:**

```python
def load_markers_smart(self):
    """L√§dt nur sichtbare Marker (Viewport-basiert)"""
    # Aktuelle Map-Bounds ermitteln
    bounds = self.map_widget.get_bounds()
    # bounds = (north, south, east, west)
    
    # API-Request mit Bounds-Filter
    url = f"{self.backend_url}/api/immi/markers/bimschg"
    params = {
        'bounds': f"{bounds[1]},{bounds[3]},{bounds[0]},{bounds[2]}",
        'limit': 1000
    }
    response = requests.get(url, params=params)
    
    # Marker hinzuf√ºgen
    for marker in response.json():
        self.add_marker(marker['lat'], marker['lon'], marker['name'])
```

**Clustering-L√∂sung (manuell):**

```python
def cluster_markers(self, markers, zoom_level):
    """Manuelle Marker-Gruppierung bei niedriger Zoom-Stufe"""
    if zoom_level < 10:
        # Grid-basiertes Clustering
        grid_size = 0.1  # ~10km
        clusters = {}
        
        for marker in markers:
            grid_key = (
                round(marker['lat'] / grid_size) * grid_size,
                round(marker['lon'] / grid_size) * grid_size
            )
            if grid_key not in clusters:
                clusters[grid_key] = []
            clusters[grid_key].append(marker)
        
        # Cluster-Marker erstellen
        for (lat, lon), group in clusters.items():
            count = len(group)
            if count > 1:
                self.add_cluster_marker(lat, lon, count)
            else:
                self.add_marker(lat, lon, group[0]['name'])
    else:
        # Einzelne Marker bei hoher Zoom-Stufe
        for marker in markers:
            self.add_marker(marker['lat'], marker['lon'], marker['name'])

def add_cluster_marker(self, lat, lon, count):
    """F√ºgt Cluster-Marker hinzu (Anzahl anzeigen)"""
    marker = self.map_widget.set_marker(
        lat, lon,
        text=f"üó∫Ô∏è {count} Anlagen",
        marker_color_circle="purple",
        marker_color_outside="purple"
    )
    return marker
```

---

### Option 2: **Matplotlib + Basemap/Cartopy** (Statisch)

**Libraries:** `matplotlib`, `cartopy`

**Vorteile:**
- ‚úÖ **Wissenschaftliche Karten** (GIS-Features)
- ‚úÖ **Heatmaps** direkt unterst√ºtzt
- ‚úÖ **Viele Projektionen** (UTM, Lambert, etc.)
- ‚úÖ **Offline-f√§hig**

**Nachteile:**
- ‚ùå **Nicht interaktiv** (keine Zoom/Pan wie Google Maps)
- ‚ùå **Langsames Rendering** bei vielen Punkten
- ‚ùå **Keine Map-Tiles** (muss manuell gezeichnet werden)

**Code-Beispiel:**

```python
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import cartopy.crs as ccrs
import cartopy.feature as cfeature

class StaticMapWidget(tk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        
        # Matplotlib Figure erstellen
        self.fig, self.ax = plt.subplots(
            subplot_kw={'projection': ccrs.PlateCarree()},
            figsize=(10, 8)
        )
        
        # Karte zeichnen
        self.ax.set_extent([11.5, 15.0, 51.0, 53.5], crs=ccrs.PlateCarree())
        self.ax.add_feature(cfeature.COASTLINE)
        self.ax.add_feature(cfeature.BORDERS, linestyle=':')
        self.ax.add_feature(cfeature.LAND, color='lightgray')
        
        # Canvas in Tkinter einbetten
        self.canvas = FigureCanvasTkAgg(self.fig, master=self)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill="both", expand=True)
    
    def add_markers(self, lats, lons, colors):
        """F√ºgt Marker hinzu"""
        self.ax.scatter(lons, lats, c=colors, s=50, alpha=0.6, 
                       transform=ccrs.PlateCarree())
        self.canvas.draw()
```

**Bewertung:** ‚ùå Nicht empfohlen (zu statisch, keine echte Interaktivit√§t)

---

### Option 3: **Folium + WebView** (Hybrid)

**Libraries:** `folium`, `tkinterweb`

**Vorteile:**
- ‚úÖ **Leaflet.js Power** (Clustering, Heatmap)
- ‚úÖ **Python-seitige Konfiguration**
- ‚úÖ **Alle Features aus TODO verf√ºgbar**

**Nachteile:**
- ‚ö†Ô∏è **Abh√§ngigkeit von Browser-Widget**
- ‚ö†Ô∏è **HTML-Kommunikation √ºber Dateien**

**Code-Beispiel:**

```python
import folium
from tkinterweb import HtmlFrame

class FoliumMapWidget(tk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        
        # Folium-Karte erstellen
        self.map = folium.Map(
            location=[52.45, 13.37],
            zoom_start=8,
            tiles='OpenStreetMap'
        )
        
        # Marker hinzuf√ºgen
        folium.Marker([52.5, 13.4], popup="Test").add_to(self.map)
        
        # Als HTML speichern
        self.map.save("temp_map.html")
        
        # In HtmlFrame laden
        self.html_frame = HtmlFrame(self, horizontal_scrollbar="auto")
        self.html_frame.load_file("temp_map.html")
        self.html_frame.pack(fill="both", expand=True)
```

**Bewertung:** ‚ö†Ô∏è Funktioniert, aber nicht "native Canvas"

---

### Option 4: **Custom Canvas Drawing** (Pure Tkinter)

**Vorteile:**
- ‚úÖ **100% Kontrolle**
- ‚úÖ **Keine externen Dependencies**
- ‚úÖ **Schnell** (direktes Canvas-Drawing)

**Nachteile:**
- ‚ùå **Sehr aufw√§ndig** (Map-Tiles, Projektionen, Zoom selbst implementieren)
- ‚ùå **Keine Map-Tiles** (nur eigene Grafiken)
- ‚ùå **Schlechte Kartendarstellung**

**Code-Beispiel:**

```python
class CustomCanvasMap(tk.Canvas):
    def __init__(self, parent, width=800, height=600):
        super().__init__(parent, width=width, height=height, bg='lightblue')
        
        self.center_lat = 52.45
        self.center_lon = 13.37
        self.zoom = 8
        
        # Background (vereinfachte Karte)
        self.create_rectangle(0, 0, width, height, fill='lightblue', outline='')
        
        # Land (Brandenburg - grob)
        self.create_polygon(
            100, 100, 700, 100, 700, 500, 100, 500,
            fill='lightgreen', outline='black'
        )
    
    def lat_lon_to_pixel(self, lat, lon):
        """Konvertiert Lat/Lon zu Canvas-Koordinaten"""
        # Mercator-Projektion (vereinfacht)
        x = (lon - self.center_lon) * 50 * (2 ** self.zoom) + 400
        y = 300 - (lat - self.center_lat) * 50 * (2 ** self.zoom)
        return x, y
    
    def add_marker(self, lat, lon, color='red'):
        """F√ºgt Marker hinzu"""
        x, y = self.lat_lon_to_pixel(lat, lon)
        self.create_oval(x-5, y-5, x+5, y+5, fill=color, outline='black')
```

**Bewertung:** ‚ùå Viel zu aufw√§ndig f√ºr professionelle Kartendarstellung

---

### Option 5: **PyQt + Leaflet WebEngine** (Alternative GUI)

**Libraries:** `PyQt5`, `QtWebEngineWidgets`

**Vorteile:**
- ‚úÖ **Vollst√§ndiges Leaflet.js**
- ‚úÖ **Native Integration** (kein separates Fenster)
- ‚úÖ **JavaScript-Python Bridge**

**Nachteile:**
- ‚ùå **Wechsel von Tkinter zu PyQt** (gro√üer Aufwand)
- ‚ùå **Schwere Dependencies** (QtWebEngine ~50 MB)

**Bewertung:** ‚ùå Nicht praktikabel (gesamtes Frontend umschreiben)

---

## üìä Vergleichstabelle

| Option | Interaktiv | Performance | Map-Tiles | Clustering | Heatmap | Aufwand | Empfehlung |
|--------|-----------|-------------|-----------|-----------|---------|---------|------------|
| **tkintermapview** | ‚úÖ | ‚≠ê‚≠ê‚≠ê | ‚úÖ | üîß Manual | ‚ùå | LOW | ‚úÖ **BESTE WAHL** |
| Matplotlib/Cartopy | ‚ùå | ‚≠ê‚≠ê | ‚ùå | ‚ùå | ‚úÖ | MEDIUM | ‚ùå |
| Folium + WebView | ‚úÖ | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚úÖ | ‚úÖ | ‚úÖ | LOW | ‚ö†Ô∏è Hybrid |
| Custom Canvas | ‚úÖ | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚ùå | üîß Manual | üîß Manual | VERY HIGH | ‚ùå |
| PyQt + Leaflet | ‚úÖ | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚úÖ | ‚úÖ | ‚úÖ | VERY HIGH | ‚ùå |

---

## ‚úÖ Empfehlung: **tkintermapview** mit Custom Clustering

### Warum?

1. ‚úÖ **Native Tkinter** - passt perfekt zur bestehenden App
2. ‚úÖ **Einfache Installation** - `pip install tkintermapview`
3. ‚úÖ **OpenStreetMap** - kostenlose, hochwertige Karten
4. ‚úÖ **Zoom/Pan** - wie Google Maps
5. ‚úÖ **Marker-Support** - mit Click-Events
6. ‚úÖ **Offline-Caching** - Tiles werden gespeichert
7. ‚úÖ **Leichtgewichtig** - keine Browser-Engine
8. ‚úÖ **Gut dokumentiert** - aktive Community

### Limitierungen & L√∂sungen:

**Problem 1: Keine Heatmap**
- **L√∂sung:** Matplotlib-Overlay f√ºr Heatmap-Layer
- Oder: Dichte-Marker (gr√∂√üere Kreise bei vielen Anlagen)

**Problem 2: Kein Auto-Clustering**
- **L√∂sung:** Manuelles Grid-Clustering (siehe Code oben)
- Bei Zoom < 10: Gruppen von Markern zusammenfassen
- Bei Zoom ‚â• 10: Einzelne Marker anzeigen

**Problem 3: Performance bei >1000 Markern**
- **L√∂sung:** Viewport-basiertes Laden (nur sichtbare Marker)
- IMMI API unterst√ºtzt `bounds` Parameter
- Dynamisches Nachladen beim Zoomen/Panning

---

## üöÄ Implementierungsplan

### Phase 1: Basic Map (2h)
```python
# frontend/ui/veritas_ui_map_widget.py
import tkinter as tk
from tkintermapview import TkinterMapView
import requests

class IMMIMapWidget(tk.Frame):
    def __init__(self, parent, backend_url="http://localhost:5000"):
        super().__init__(parent)
        
        # Map erstellen
        self.map = TkinterMapView(self, width=800, height=600)
        self.map.pack(fill="both", expand=True)
        self.map.set_position(52.45, 13.37)
        self.map.set_zoom(8)
        
        # Marker laden
        self.load_markers()
    
    def load_markers(self):
        # Von IMMI API laden
        pass
```

### Phase 2: Marker & Clustering (3h)
- Custom Icons f√ºr BImSchG/WKA
- Grid-basiertes Clustering
- Click-Events f√ºr Info-Dialogs

### Phase 3: Filter-UI (2h)
- Sidebar mit Filter-Optionen
- API-Integration f√ºr Filter-Queries
- Dynamisches Marker-Update

### Phase 4: Optimierung (1h)
- Viewport-basiertes Laden
- Caching von Marker-Daten
- Smooth Zoom-Transitions

**Gesamtaufwand:** 8 Stunden (statt 16h mit Leaflet.js)

---

## üì¶ Installation

```bash
# tkintermapview installieren
pip install tkintermapview

# Optional: Pillow f√ºr Custom Icons
pip install Pillow
```

**Dependencies:**
- `tkintermapview` (~50 KB)
- `requests` (bereits vorhanden)
- `Pillow` (optional, f√ºr Icons)

**Keine Browser-Engine, kein JavaScript, kein HTML!** üéâ

---

## üéØ Fazit

**Native Tkinter Canvas-L√∂sung:** ‚úÖ **M√ñGLICH & EMPFOHLEN**

Mit `tkintermapview` bekommen Sie:
- ‚úÖ Interaktive Karte (Zoom, Pan, Click)
- ‚úÖ OpenStreetMap Tiles (kostenlos)
- ‚úÖ Native Tkinter-Integration
- ‚úÖ Marker mit Custom Icons
- ‚úÖ Performance (mit Viewport-Loading)
- ‚úÖ Offline-Caching

**Ohne:**
- ‚ùå Browser-Widget
- ‚ùå HTML/JavaScript
- ‚ùå Schwere Dependencies
- ‚ùå Komplexe Integration

**Zeit bis zur funktionierenden Karte:** ~2 Stunden! ‚ö°

---

**N√§chster Schritt:** `pip install tkintermapview` und los geht's! üöÄ
