#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VERITAS Protected Module
WARNING: This file contains embedded protection keys. 
Modification will be detected and may result in license violations.
"""

# Unterdr√ºcke UDS3 Module Warnings (v3.20.0)
import warnings
warnings.filterwarnings('ignore', message='.*module not available.*')
warnings.filterwarnings('ignore', message='.*not available for PolyglotQuery.*')


# -*- coding: utf-8 -*-
"""
Veritas Modern App - Frontend GUI f√ºr VERITAS Backend
Reine HTTP/HTTPS-basierte Kommunikation mit dem Backend
Keine direkten Datenbankzugriffe oder UDS3-Abh√§ngigkeiten
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import os
import sys
import json
import logging
import queue
import threading
import requests
import time
from datetime import datetime
from typing import Dict, List, Optional, Any

# F√ºge das Projekt-Root zum Python-Pfad hinzu
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)  # Ein Verzeichnis h√∂her als frontend/
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Logger f√ºr dieses Modul definieren  
logger = logging.getLogger(__name__)

# Universal JSON Payload Library Import
try:
    from shared.universal_json_payload import (
        UniversalQueryRequest, UniversalQueryResponse,
        RequestType, ResponseStatus, SystemComponent, QualityLevel,
        create_request_id, create_session_id, validate_request_type
    )
    PAYLOADS_AVAILABLE = True
    logger.info("‚úÖ Universal JSON Payload Library geladen")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è Universal JSON Payloads nicht verf√ºgbar: {e}")
    PAYLOADS_AVAILABLE = False

# VERITAS Core Engine Import  
try:
    from shared.core.veritas_core import (
        VeritasCore, ThreadManager, SessionManager, BackendProcessor,
        MessageType, QueueMessage, ChatMessage, StatusMessage, BackendResponse,
        create_veritas_core, create_chat_message, create_status_message
    )
    CORE_AVAILABLE = True
    logger.info("‚úÖ VERITAS Core Engine erfolgreich geladen")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è VERITAS Core nicht verf√ºgbar - verwende interne Fallback-Implementation")
    CORE_AVAILABLE = False

# UI-Komponenten importieren
try:
    from frontend.ui.veritas_ui_components import Tooltip
    from frontend.ui.veritas_ui_feedback_system import MessageFeedbackWidget
    UI_COMPONENTS_AVAILABLE = True
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è UI-Komponenten nicht verf√ºgbar: {e}")
    UI_COMPONENTS_AVAILABLE = False

# UI-Module f√ºr Modularisierung importieren
try:
    from frontend.ui.veritas_ui_markdown import MarkdownRenderer, setup_markdown_tags
    from frontend.ui.veritas_ui_source_links import SourceLinkHandler
    from frontend.ui.veritas_ui_chat_formatter import ChatDisplayFormatter, setup_chat_tags
    from frontend.ui.veritas_ui_dialogs import DialogManager
    UI_MODULES_AVAILABLE = True
    logger.info("‚úÖ UI-Module erfolgreich geladen (Markdown, SourceLinks, ChatFormatter, Dialogs)")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è UI-Module nicht verf√ºgbar: {e}")
    UI_MODULES_AVAILABLE = False

# Office Export Integration
try:
    from frontend.services.office_export import OfficeExportService
    from frontend.ui.veritas_ui_export_dialog import ExportDialog
    OFFICE_EXPORT_AVAILABLE = True
    logger.info("‚úÖ Office Export Module geladen (Word/Excel)")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è Office Export nicht verf√ºgbar: {e}")
    OFFICE_EXPORT_AVAILABLE = False

# Konfiguration
try:
    from config import Config
    API_BASE_URL = Config().API_BASE_URL
except ImportError:
    API_BASE_URL = "http://127.0.0.1:5000"  # Server l√§uft auf Port 5000

# Streaming Integration
try:
    from backend.services.veritas_streaming_service import (
        VeritasStreamingService, StreamingUIMixin, StreamingMessageType,
        setup_streaming_chat_tags
    )
    STREAMING_AVAILABLE = True
    logger.info("‚úÖ Streaming Service verf√ºgbar")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è Streaming Service nicht verf√ºgbar: {e}")
    STREAMING_AVAILABLE = False
    
    # Fallback Mixin
    class StreamingUIMixin:
        def __init__(self): pass
        def init_streaming_ui(self, parent): pass
        def setup_streaming_integration(self, window_id, thread_manager): pass
        def _handle_streaming_message(self, message): pass

# Versionsinformationen
__version__ = "3.15.0"
__history__ = [
    {"version": "3.15.0", "date": "2025-10-09", "changes": [
        "üéâ MILESTONE: 15/15 Rich-Text Enhancement Features COMPLETE! üèÜ",
        "üìä Feature #2: Markdown-Tabellen-Support implementiert (~30 min)",
        "   ‚Ä¢ Automatische Tabellen-Erkennung (| Header | Header |)",
        "   ‚Ä¢ Parser f√ºr mehrzeilige Tabellen mit Separator-Detection",
        "   ‚Ä¢ Box-Drawing-Characters f√ºr elegante Borders (‚îå‚îÄ‚î¨‚îÄ‚îê)",
        "   ‚Ä¢ Spalten-Breiten-Berechnung basierend auf Content",
        "   ‚Ä¢ Monospace-Font (Courier New 9) f√ºr perfektes Alignment",
        "   ‚Ä¢ Alternierende Row-Colors (wei√ü/grau) f√ºr Lesbarkeit",
        "   ‚Ä¢ _parse_table() - 2D-Array-Parsing mit Separator-Skip",
        "   ‚Ä¢ _render_table() - Header (bold) + Data-Rows + Borders",
        "   ‚Ä¢ 4 neue Tkinter-Tags: table_header, table_cell, table_cell_alt, table_border",
        "‚ú® 100% Feature-Roadmap abgeschlossen:",
        "   ‚Ä¢ Feature #1: Collapsible Sections ‚úÖ",
        "   ‚Ä¢ Feature #2: Tables ‚úÖ (NEW)",
        "   ‚Ä¢ Feature #3: Syntax-Highlighting ‚úÖ",
        "   ‚Ä¢ Feature #4: Listen-Formatierung ‚úÖ",
        "   ‚Ä¢ Feature #5: Scroll-to-Source ‚úÖ",
        "   ‚Ä¢ Feature #6: Code Copy-Button ‚úÖ",
        "   ‚Ä¢ Feature #7: Source-Hover ‚úÖ",
        "   ‚Ä¢ Feature #10: Custom Icons ‚úÖ",
        "   ‚Ä¢ Feature #11: Keyboard Shortcuts ‚úÖ",
        "   ‚Ä¢ Feature #12: Confidence Badges ‚úÖ",
        "   ‚Ä¢ Feature #13: Enhanced Icons ‚úÖ",
        "   ‚Ä¢ Feature #14: Relative Timestamps ‚úÖ"
    ]},
    {"version": "3.14.0", "date": "2025-10-09", "changes": [
        "‚ú® Quick Wins: Features #12, #13, #14 implementiert (~25 min)",
        "üéØ Feature #12: Confidence-Score Visualisierung mit farbigen Badges",
        "   ‚Ä¢ Gr√ºne Badges f√ºr hohe Scores (‚â•80%)",
        "   ‚Ä¢ Orange Badges f√ºr mittlere Scores (60-79%)",
        "   ‚Ä¢ Rote Badges f√ºr niedrige Scores (<60%)",
        "   ‚Ä¢ Background-Color Tags in Tkinter",
        "üìÅ Feature #13: Erweiterte Source-Type Icons",
        "   ‚Ä¢ 50+ neue Dateityp-Icons (csv, json, xml, sql)",
        "   ‚Ä¢ Code-Dateien: üêç Python, üìú JavaScript, ‚òï Java, etc.",
        "   ‚Ä¢ Media-Dateien: üé¨ Video, üéµ Audio, üñºÔ∏è Bilder",
        "   ‚Ä¢ Archive-Formate: üì¶ ZIP, RAR, TAR, etc.",
        "üïê Feature #14: Relative Timestamp-Formatierung",
        "   ‚Ä¢ 'Heute 14:23', 'Gestern 10:15', 'Mo 09:30'",
        "   ‚Ä¢ Automatische relative Zeitangaben (<7 Tage)",
        "   ‚Ä¢ format_relative_timestamp() Utility-Funktion",
        "   ‚Ä¢ Fallback auf Datum bei √§lteren Nachrichten"
    ]},
    {"version": "3.13.0", "date": "2025-10-09", "changes": [
        "‚ú® Rich-Text Enhancement #1: Collapsible Sections implementiert",
        "üì¶ Neue CollapsibleSection-Klasse in veritas_ui_components.py",
        "üîΩ Toggle-Funktionalit√§t mit ‚ñ∂/‚ñº Icons f√ºr Expand/Collapse",
        "üìö Quellen-Section collapsible (initial eingeklappt)",
        "ü§ñ Agent-Analysen-Section collapsible (initial eingeklappt)",
        "üí° Vorschl√§ge-Section collapsible (initial sichtbar)",
        "üéØ Message-ID-basiertes State-Management f√ºr individuelle Sections",
        "‚ö° Optional: Smooth Expand/Collapse-Animation",
        "üîß Fallback auf alte Details-Toggle-Methode wenn Feature nicht verf√ºgbar",
        "üé® Integration mit dynamischem Icon-System (Feature #10)",
        "üñ±Ô∏è Click-Handler f√ºr Header und Arrow-Icons",
        "üìù Helper-Methode _insert_single_source() f√ºr modulare Quellen-Darstellung"
    ]},
    {"version": "3.12.0", "date": "2025-10-09", "changes": [
        "‚ú® Rich-Text Enhancement #11: Keyboard Shortcuts implementiert",
        "‚å®Ô∏è Global Shortcuts: Ctrl+N (Neuer Chat), Ctrl+S (Speichern), Ctrl+O (Laden)",
        "üóëÔ∏è Ctrl+K (Chat l√∂schen), Ctrl+/ (Shortcuts anzeigen), Esc (Focus Input), F1 (Hilfe)",
        "üí° Shortcuts-Hilfe-Dialog mit vollst√§ndiger √úbersicht",
        "üîß Tooltips f√ºr alle Toolbar-Buttons mit Shortcuts",
        "üìã Hamburger-Men√º erweitert mit Shortcuts-Eintrag",
        "‚ú® Rich-Text Enhancement #4: Liste-Formatierung implementiert",
        "üìù Auto-Indentation f√ºr nested Lists (2 Spaces = 1 Level)",
        "üî¢ Nummerierte Listen (1., 2., 3., ...)",
        "üî§ Alphabetische Listen (a., b., c. & A., B., C.)",
        "üèõÔ∏è R√∂mische Ziffern (i., ii., iii. & I., II., III.)",
        "‚ö° Dynamische Icon-Integration aus Feature #10"
    ]},
    {"version": "3.11.0", "date": "2025-10-09", "changes": [
        "‚ú® Rich-Text Enhancement #10: Custom Icons System implementiert",
        "üé® Zentrale Icon-Verwaltung in veritas_ui_icons.py (300+ Zeilen)",
        "üìö 10+ Icon-Kategorien: Chat, Sources, Metadata, Agents, Actions, Status, Files, Navigation",
        "üîß Dynamische Icon-Auswahl basierend auf Kontext (Datei-Typ, Confidence-Score, etc.)",
        "üìñ Shortcut-Methoden f√ºr schnellen Zugriff (VeritasIcons.chat(), .source(), .file())",
        "üéØ ChatDisplayFormatter verwendet jetzt dynamische Icons f√ºr Sections",
        "üìù MarkdownRenderer unterst√ºtzt Custom Icons f√ºr Listen",
        "‚ö° Fallback-Icons wenn Icon-System nicht verf√ºgbar"
    ]},
    {"version": "3.10.0", "date": "2025-10-09", "changes": [
        "‚ú® Rich-Text Enhancement #5: Scroll-to-Source Animation implementiert",
        "üé¨ Smooth Scroll Animation mit Cubic Easing Funktion (500ms, 30 FPS)",
        "üí° Flash-Highlight der Ziel-Zeile mit Fade-out-Effekt (Gelb ‚Üí Wei√ü, 2s)",
        "üéØ Click-Handler f√ºr Quellen-Links l√∂sen jetzt Scroll-Animation aus",
        "üìç Automatische Positionierung mit 3-Zeilen-Padding f√ºr Sichtbarkeit",
        "‚ö° Intelligente Erkennung ob Scroll n√∂tig ist (Skip bei bereits sichtbar)",
        "üõ°Ô∏è Robuste Error-Handling f√ºr Edge-Cases",
        "Erweitert: ChatDisplayFormatter.scroll_to_source() & highlight_line()"
    ]},
    {"version": "3.9.0", "date": "2025-10-09", "changes": [
        "‚ú® Rich-Text Enhancement #3: Syntax-Highlighting mit Pygments implementiert",
        "üé® Code-Bl√∂cke werden jetzt farblich hervorgehoben (Python, JS, SQL, JSON, etc.)",
        "üì¶ Neues Modul: veritas_ui_syntax.py mit SyntaxHighlighter-Klasse",
        "üîç Automatische Sprach-Erkennung aus Code-Fences (```python)",
        "üé® VS Code Dark+ Theme inspiriertes Farbschema",
        "‚ö° Token-basiertes Rendering mit Pygments ‚Üí Tkinter Tag Mapping",
        "üõ°Ô∏è Fallback auf Text-Lexer wenn Sprache unbekannt",
        "Unterst√ºtzt: Python, JavaScript, TypeScript, SQL, JSON, Bash, Markdown u.v.m."
    ]},
    {"version": "3.8.0", "date": "2025-10-09", "changes": [
        "‚ú® Rich-Text Enhancement #6: Copy-Button f√ºr Code implementiert",
        "üìã Copy-Button erscheint automatisch neben Code-Bl√∂cken",
        "‚úì Visual Feedback mit Checkmark-Animation (1.5s)",
        "üé® Hover-Effekt f√ºr bessere UX (#666 ‚Üí #0066CC)",
        "üõ°Ô∏è Error Handling mit ‚úó Icon",
        "‚ö° Automatische Integration in MarkdownRenderer",
        "Nur f√ºr Code-Snippets > 3 Zeichen aktiviert"
    ]},
    {"version": "3.7.0", "date": "2025-10-09", "changes": [
        "‚ú® Rich-Text Enhancement #7: Quellen-Hover-Preview implementiert",
        "Hover-Tooltips zeigen Snippet-Vorschau, Confidence-Score, Metadaten",
        "Async Backend-Integration f√ºr Snippet-Extraktion (POST /database/get_snippet)",
        "Farbcodierte Confidence-Anzeige (Gr√ºn/Orange/Rot)",
        "Automatische Tooltip-Bindung f√ºr alle Quellen (URLs, Dateien, DB)",
        "Dark Theme Tooltips (#2c3e50) mit intelligenter Textk√ºrzung",
        "Erweiterte SourceTooltip-Klasse mit fetch_snippet Feature"
    ]},
    {"version": "3.6.0", "date": "2025-10-09", "changes": [
        "UI-Komponenten in separate Module ausgelagert",
        "Markdown-Rendering modularisiert (veritas_ui_markdown.py)",
        "Dialog-Management zentralisiert (veritas_ui_dialogs.py)",
        "Chat-Formatter ausgelagert (veritas_ui_chat_formatter.py)",
        "Source-Link-Handler modularisiert (veritas_ui_source_links.py)",
        "Code-Reduktion: ~970 Zeilen (-19.4%)",
        "Verbesserte Wartbarkeit und Testbarkeit"
    ]},
    {"version": "3.5.0", "date": "2025-10-05", "changes": ["Alle UDS3-Abh√§ngigkeiten entfernt", "Reine HTTP/HTTPS Backend-Kommunikation", "Frontend komplett unabh√§ngig vom Backend-Typ"]},
    {"version": "3.4.0", "date": "2025-08-21", "changes": ["OOP-Architektur implementiert", "Thread-Manager f√ºr Multi-Window-Support", "Queue-basierte Nachrichten-System", "Moderne GUI mit korrekter Architektur"]},
    {"version": "3.2.0", "date": "2025-08-21", "changes": ["Moderne Chat GUI integriert", "Einheitliches Design System", "Kompakte Steuerung"]},
]

# === OOP-ARCHITEKTUR: CORE ENGINE INTEGRATION ===

from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod

# Fallback Implementierungen falls Core Engine nicht verf√ºgbar
if not CORE_AVAILABLE:
    logger.warning("‚ö†Ô∏è Verwende Fallback-Implementierung f√ºr Core Engine")
    
    class MessageType(Enum):
        """Definiert verschiedene Message-Typen f√ºr Queue-Kommunikation"""
        CHAT_MESSAGE = "chat_message"
        STATUS_UPDATE = "status_update"
        WINDOW_CLOSE = "window_close"
        WINDOW_TRANSFER = "window_transfer"
        BACKEND_RESPONSE = "backend_response"
        ERROR_MESSAGE = "error_message"
        THREAD_SHUTDOWN = "thread_shutdown"

    @dataclass
    class QueueMessage:
        """Base class f√ºr Queue-Nachrichten"""
        msg_type: MessageType
        sender_id: str
        timestamp: float
        data: Dict[str, Any]

    @dataclass
    class ChatMessage(QueueMessage):
        """Spezielle Nachricht f√ºr Chat-Inhalte"""
        def __init__(self, sender_id: str, role: str, content: str, **kwargs):
            super().__init__(
                msg_type=MessageType.CHAT_MESSAGE,
                sender_id=sender_id,
                timestamp=datetime.now().timestamp(),
                data={
                    'role': role,
                    'content': content,
                    'chat_id': kwargs.get('chat_id'),
                    **kwargs
                }
            )

    @dataclass
    class StatusMessage(QueueMessage):
        """Status-Updates zwischen Threads"""
        def __init__(self, sender_id: str, status: str, details: Optional[Dict] = None):
            super().__init__(
                msg_type=MessageType.STATUS_UPDATE,
                sender_id=sender_id,
                timestamp=datetime.now().timestamp(),
                data={'status': status, 'details': details or {}}
            )

# === FALLBACK THREAD MANAGER ===

if not CORE_AVAILABLE:
    class ThreadManager:
        """Fallback ThreadManager falls Core Engine nicht verf√ºgbar"""
        
        def __init__(self):
            self.threads: Dict[str, threading.Thread] = {}
            self.queues: Dict[str, queue.Queue] = {}
            self.main_queue = queue.Queue()
            self.shutdown_event = threading.Event()
            self._lock = threading.Lock()
            
            logger.info("Fallback ThreadManager initialisiert")
        
        def create_thread_queue(self, thread_id: str) -> queue.Queue:
            """Erstellt eine neue Queue f√ºr einen Thread"""
            with self._lock:
                thread_queue = queue.Queue()
                self.queues[thread_id] = thread_queue
                logger.info(f"Queue f√ºr Thread {thread_id} erstellt")
                return thread_queue
        
        def register_thread(self, thread_id: str, thread: threading.Thread):
            """Registriert einen neuen Thread"""
            with self._lock:
                self.threads[thread_id] = thread
                logger.info(f"Thread {thread_id} registriert")
        
        def send_message(self, target_id: str, message: QueueMessage):
            """Sendet eine Nachricht an einen spezifischen Thread"""
            with self._lock:
                if target_id in self.queues:
                    self.queues[target_id].put(message)
                    logger.debug(f"Message {message.msg_type} an {target_id} gesendet")
                else:
                    logger.warning(f"Thread {target_id} nicht gefunden f√ºr Message {message.msg_type}")
        
        def broadcast_message(self, message: QueueMessage, exclude: Optional[List[str]] = None):
            """Sendet eine Nachricht an alle Threads"""
            exclude = exclude or []
            with self._lock:
                for thread_id, thread_queue in self.queues.items():
                    if thread_id not in exclude:
                        thread_queue.put(message)
                logger.debug(f"Broadcast {message.msg_type} an {len(self.queues) - len(exclude)} Threads")
        
        def remove_thread(self, thread_id: str):
            """Entfernt einen Thread thread-sicher aus der Verwaltung"""
            try:
                with self._lock:
                    if thread_id in self.threads:
                        thread = self.threads[thread_id]
                        del self.threads[thread_id]
                        logger.info(f"Thread {thread_id} entfernt")
                    
                    if thread_id in self.queues:
                        try:
                            while not self.queues[thread_id].empty():
                                self.queues[thread_id].get_nowait()
                        except:
                            pass
                        del self.queues[thread_id]
                        logger.info(f"Queue f√ºr {thread_id} entfernt")
            except Exception as e:
                logger.error(f"Fehler beim Entfernen von Thread {thread_id}: {e}")
        
        def shutdown_all(self):
            """Beendet alle Threads sauber"""
            self.shutdown_event.set()
            shutdown_msg = QueueMessage(
                MessageType.THREAD_SHUTDOWN, 
                "ThreadManager", 
                datetime.now().timestamp(), 
                {}
            )
            self.broadcast_message(shutdown_msg)
            
            with self._lock:
                for thread_id, thread in self.threads.items():
                    thread.join(timeout=2.0)
                    logger.info(f"Thread {thread_id} beendet")
            
            logger.info("Alle Threads beendet")
    
    class VeritasCore:
        """Fallback VERITAS Core falls Core Engine nicht verf√ºgbar"""
        def __init__(self):
            self.thread_manager = ThreadManager()
            self.session_manager = None
            self.backend_processor = None
            logger.info("Fallback VeritasCore initialisiert")
    
    def create_veritas_core() -> VeritasCore:
        """Erstellt eine Fallback Core Instance"""
        return VeritasCore()

# === CORE ENGINE INITIALIZATION ===

# Global Core Engine Instance
veritas_core_instance: Optional[VeritasCore] = None

def get_veritas_core() -> VeritasCore:
    """Singleton Pattern f√ºr VERITAS Core Engine"""
    global veritas_core_instance
    
    if veritas_core_instance is None:
        if CORE_AVAILABLE:
            veritas_core_instance = create_veritas_core()
            logger.info("‚úÖ VERITAS Core Engine initialisiert")
        else:
            logger.warning("‚ö†Ô∏è Core Engine nicht verf√ºgbar - verwende lokale Implementierung")
            
    return veritas_core_instance

# Thread Manager aus Core Engine oder Fallback
if CORE_AVAILABLE:
    # Verwende Core Engine ThreadManager
    def get_thread_manager() -> ThreadManager:
        return get_veritas_core().thread_manager
else:
    # Verwende lokale Fallback-Implementierung
    _fallback_thread_manager: Optional[ThreadManager] = None
    
    def get_thread_manager() -> ThreadManager:
        global _fallback_thread_manager
        if _fallback_thread_manager is None:
            _fallback_thread_manager = ThreadManager()
        return _fallback_thread_manager

# === OOP-ARCHITEKTUR: CHAT WINDOW BASE CLASS ===

class ChatWindowBase(ABC, StreamingUIMixin if STREAMING_AVAILABLE else object):
    """Abstrakte Basis-Klasse f√ºr alle Chat-Fenster"""
    
    def __init__(self, window_id: str, thread_manager: ThreadManager, parent=None):
        # Basis-Initialisierung
        self.window_id = window_id
        self.thread_manager = thread_manager
        self.parent = parent
        self.chat_messages = []
        self.is_main_window = False
        
        # Session-ID f√ºr API-Kommunikation
        self.session_id = f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{window_id}"
        self.selected_llm = None  # Wird dynamisch vom Backend geladen
        
        # Thread-spezifische Queue erstellen - Verwende direkte Queue-Referenz
        self.queue = thread_manager.create_thread_queue(window_id)
        self.message_queue = self.queue  # Alias f√ºr Kompatibilit√§t
        
        # GUI-Komponenten
        self.window = None
        self.chat_text = None
        self.input_text = None
        self.status_var = None
        
        # Feedback-System
        self.feedback_widgets = {}  # message_id -> MessageFeedbackWidget
        self.last_assistant_message_id = None
        
        # Streaming-Integration Setup
        if STREAMING_AVAILABLE:
            try:
                # StreamingUIMixin Initialisierung
                StreamingUIMixin.__init__(self)
                # Streaming-Service an Window binden
                self.setup_streaming_integration(window_id, thread_manager)
                logger.info(f"‚úÖ Streaming-Integration f√ºr {window_id} aktiviert")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Streaming-Integration fehlgeschlagen f√ºr {window_id}: {e}")
        
        logger.info(f"ChatWindowBase {window_id} initialisiert")
    
    @abstractmethod
    def create_gui(self):
        """Erstellt die GUI-Komponenten - muss von Subklassen implementiert werden"""
        pass
    
    @abstractmethod
    def setup_bindings(self):
        """Richtet Event-Bindings ein - muss von Subklassen implementiert werden"""
        pass
    
    def start_message_loop(self):
        """Startet die Message-Loop f√ºr diese Window"""
        thread = threading.Thread(
            target=self._message_loop,
            daemon=True,
            name=f"ChatWindow-{self.window_id}"
        )
        self.thread_manager.register_thread(self.window_id, thread)
        thread.start()
        logger.info(f"Message-Loop f√ºr {self.window_id} gestartet")
    
    def _message_loop(self):
        """Interne Message-Loop - l√§uft in separatem Thread"""
        while not self.thread_manager.shutdown_event.is_set():
            try:
                message = self.message_queue.get(timeout=0.1)
                self._handle_message(message)
                self.message_queue.task_done()
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"Fehler in Message-Loop {self.window_id}: {e}")
    
    def _handle_message(self, message: QueueMessage):
        """Behandelt eingehende Nachrichten"""
        # Erst pr√ºfen ob es Streaming-Message ist
        if (STREAMING_AVAILABLE and hasattr(message, 'data') and 
            isinstance(message.data, dict) and 'stream_type' in message.data):
            self._handle_streaming_message(message)
        elif message.msg_type == MessageType.CHAT_MESSAGE:
            self._handle_chat_message(message)
        elif message.msg_type == MessageType.STATUS_UPDATE:
            self._handle_status_update(message)
        elif message.msg_type == MessageType.BACKEND_RESPONSE:
            self._handle_backend_response(message)
        elif message.msg_type == MessageType.ERROR_MESSAGE:
            self._handle_error_message(message)
        elif message.msg_type == MessageType.THREAD_SHUTDOWN:
            self._handle_shutdown()
        else:
            logger.debug(f"Unbehandelte Message: {message.msg_type} in {self.window_id}")
    
    def _handle_chat_message(self, message: QueueMessage):
        """Behandelt Chat-Nachrichten"""
        chat_data = message.data
        self.chat_messages.append({
            'role': chat_data['role'],
            'content': chat_data['content'],
            'timestamp': datetime.fromtimestamp(message.timestamp).isoformat()
        })
        
        # Auto-Save nach jeder User-Message
        if chat_data['role'] == 'user':
            self._auto_save_conversation()
        
        # GUI-Update in Main-Thread
        if self.window:
            self.window.after(0, self.update_chat_display)
    
    def _handle_status_update(self, message: QueueMessage):
        """Behandelt Status-Updates thread-sicher"""
        try:
            status = message.data.get('status', 'Unknown')
            if self.status_var and self.window and hasattr(self.window, 'winfo_exists') and self.window.winfo_exists():
                self.window.after(0, self._safe_update_status, status)
        except tk.TclError:
            logger.debug(f"Status-Update f√ºr {self.window_id} - Window bereits zerst√∂rt")
        except Exception as e:
            logger.error(f"Fehler bei Status-Update f√ºr {self.window_id}: {e}")
    
    def _safe_update_status(self, status):
        """Sicheres Status-Update mit Widget-Existenz-Pr√ºfung"""
        try:
            if self.status_var and self.window and hasattr(self.window, 'winfo_exists') and self.window.winfo_exists():
                self.status_var.set(status)
        except tk.TclError:
            logger.debug(f"Status-Update f√ºr {self.window_id} - Widget bereits zerst√∂rt")
        except Exception as e:
            logger.debug(f"Fehler bei Status-Update: {e}")
    
    def _handle_backend_response(self, message: QueueMessage):
        """Behandelt Backend-Antworten mit erweiterten RAG-Daten"""
        logger.info(f"üîî _handle_backend_response aufgerufen f√ºr {self.window_id}")
        response_data = message.data
        
        # Hole die Basis-Antwort
        base_content = response_data.get('content', 'Keine Antwort')
        logger.debug(f"Base content length: {len(base_content)}")
        
        # üÜï Pr√ºfe auf Simulation und f√ºge Warnung hinzu
        metadata = response_data.get('metadata', {})
        has_simulation = metadata.get('has_simulation', False)
        
        # Alternativ: Pr√ºfe worker_results auf Simulation
        if not has_simulation:
            worker_results = response_data.get('worker_results', {})
            has_simulation = any(
                result.get('is_simulation', False) 
                for result in worker_results.values()
            )
        
        # Erweitere mit zus√§tzlichen Informationen
        formatted_content = base_content
        
        # F√ºge Quellen hinzu (wenn vorhanden und noch nicht im content)
        sources = response_data.get('sources', [])
        if sources and 'üìö' not in base_content:
            formatted_content += "\n\nüìö **Quellen:**"
            for i, source in enumerate(sources[:5], 1):  # Max 5 Quellen
                title = source.get('title', f'Quelle {i}')
                relevance = source.get('relevance', source.get('score', 0))
                if relevance > 0:
                    formatted_content += f"\n  {i}. {title} (Relevanz: {relevance:.0%})"
                else:
                    formatted_content += f"\n  {i}. {title}"
        
        # F√ºge Worker-Results Details hinzu (wenn vorhanden und noch nicht im content)
        worker_results = response_data.get('worker_results', {})
        if worker_results and 'ü§ñ' not in base_content and len(worker_results) > 0:
            formatted_content += f"\n\nü§ñ **Verarbeitet von {len(worker_results)} Agenten:**"
            for agent_name, agent_data in list(worker_results.items())[:3]:  # Max 3 Agents
                confidence = agent_data.get('confidence_score', 0)
                processing_time = agent_data.get('processing_time', 0)
                formatted_content += f"\n  ‚Ä¢ {agent_name}: {confidence:.0%} Confidence ({processing_time:.2f}s)"
        
        # Erweiterte Assistant-Message mit RAG-Daten
        assistant_message = {
            'role': 'assistant',
            'content': formatted_content,
            'timestamp': datetime.fromtimestamp(message.timestamp).isoformat(),
            'sources': sources,
            'worker_results': worker_results,
            'metadata': response_data.get('metadata', {}),
            'confidence_score': response_data.get('confidence_score', 0.0)
        }
        
        # ‚ú® v3.19.0: F√ºge sources_metadata hinzu (IEEE-Zitationen)
        if 'sources_metadata' in response_data:
            assistant_message['metadata']['sources_metadata'] = response_data['sources_metadata']
        
        # ‚ú® v3.19.0: F√ºge suggestions hinzu (Follow-up-Fragen)
        if 'suggestions' in response_data:
            assistant_message['metadata']['suggestions'] = response_data['suggestions']
        
        self.chat_messages.append(assistant_message)
        logger.info(f"üìù Assistant message zu chat_messages hinzugef√ºgt. Total: {len(self.chat_messages)}")
        
        # Auto-Save nach jeder Assistant-Antwort
        self._auto_save_conversation()
        
        logger.info(f"üì∫ Aktualisiere Chat-Display via window.after()")
        if self.window and hasattr(self.window, 'winfo_exists') and self.window.winfo_exists():
            self.window.after(0, self._safe_update_chat_display)
            # Status mit Quellenanzahl und Confidence
            sources_count = len(sources)
            confidence = response_data.get('confidence_score', 0.0)
            if sources_count > 0 and confidence > 0:
                status_text = f"Bereit - {sources_count} Quellen, {confidence:.0%} Confidence"
            elif sources_count > 0:
                status_text = f"Bereit - {sources_count} Quellen"
            elif confidence > 0:
                status_text = f"Bereit - {confidence:.0%} Confidence"
            else:
                status_text = "Bereit"
            self.window.after(0, self._safe_update_status, status_text)
            logger.info(f"‚úÖ Chat-Display-Update und Status-Update angefordert")
        else:
            logger.warning(f"‚ö†Ô∏è Window existiert nicht mehr f√ºr {self.window_id}")
    
    def _handle_error_message(self, message: QueueMessage):
        """Behandelt Fehlernachrichten"""
        error_data = message.data
        error_message = {
            'role': 'system',
            'content': f"‚ùå {error_data.get('content', 'Unbekannter Fehler')}",
            'timestamp': datetime.fromtimestamp(message.timestamp).isoformat()
        }
        self.chat_messages.append(error_message)
        
        if self.window and hasattr(self.window, 'winfo_exists') and self.window.winfo_exists():
            self.window.after(0, self._safe_update_chat_display)
            self.window.after(0, self._safe_update_status, "Fehler")
    
    def _on_suggestion_clicked(self, suggestion_text: str):
        """
        ‚ú® v3.19.0: Callback f√ºr klickbare Vorschl√§ge
        
        Args:
            suggestion_text: Der geklickte Vorschlagstext (z.B. "Welche Kosten fallen an?")
        
        Verhalten:
            1. F√ºllt Query-Input mit Vorschlagstext
            2. Sendet Query automatisch ans Backend
            3. Fokussiert Chat (f√ºr sofortiges Feedback)
        """
        logger.info(f"[SUGGESTION-CLICK] User clicked suggestion: {suggestion_text[:60]}...")
        
        try:
            # 1. Query-Input f√ºllen
            if hasattr(self, 'query_entry') and self.query_entry:
                self.query_entry.delete(0, tk.END)
                self.query_entry.insert(0, suggestion_text)
                logger.debug(f"[SUGGESTION] Query-Input gef√ºllt: {suggestion_text[:60]}...")
            
            # 2. Auto-Send (simuliert Enter-Taste)
            # WICHTIG: Verwende after() um Race-Conditions zu vermeiden
            self.window.after(100, self._send_query_from_suggestion)
            
            # 3. Fokus auf Chat (f√ºr visuelles Feedback)
            if hasattr(self, 'chat_text') and self.chat_text:
                self.chat_text.see(tk.END)
            
            logger.info(f"[SUGGESTION] Auto-Send initiiert f√ºr: {suggestion_text[:60]}...")
            
        except Exception as e:
            logger.error(f"[SUGGESTION-CLICK] Fehler beim Verarbeiten: {e}")
            # Fallback: Zeige Fehlermeldung
            if hasattr(self, 'status_var') and self.status_var:
                self.status_var.set(f"‚ùå Fehler beim Senden des Vorschlags")
    
    def _send_query_from_suggestion(self):
        """
        ‚ú® v3.19.0: Sendet Query aus Suggestion-Click
        
        WICHTIG: Separate Methode f√ºr after()-Callback (vermeidet Race-Conditions)
        """
        try:
            # Rufe existierende Send-Methode auf
            if hasattr(self, 'send_query'):
                self.send_query()
                logger.info("[SUGGESTION] Query erfolgreich gesendet")
            else:
                logger.warning("[SUGGESTION] send_query() Methode nicht verf√ºgbar")
        except Exception as e:
            logger.error(f"[SUGGESTION] Fehler beim Senden der Query: {e}")
    
    def _handle_shutdown(self):
        """Behandelt Shutdown-Signal thread-sicher"""
        try:
            if self.window and self.window.winfo_exists():
                self.window.after(0, self._safe_destroy)
        except tk.TclError:
            # Widget bereits zerst√∂rt
            pass
    
    def _safe_destroy(self):
        """Sicheres Zerst√∂ren des Windows"""
        try:
            if hasattr(self, 'window') and self.window and hasattr(self.window, 'winfo_exists') and self.window.winfo_exists():
                self.window.destroy()
        except tk.TclError:
            # Widget bereits zerst√∂rt
            logger.debug(f"Widget {self.window_id} bereits zerst√∂rt")
        except Exception as e:
            logger.debug(f"Fehler beim Zerst√∂ren von {self.window_id}: {e}")
    
    def _auto_save_conversation(self):
        """Speichert Conversation automatisch"""
        try:
            if not self.chat_messages:
                return
            
            # Erstelle Conversations-Ordner falls nicht vorhanden
            import os
            conversations_dir = os.path.join(os.getcwd(), "conversations")
            os.makedirs(conversations_dir, exist_ok=True)
            
            # Dateiname basierend auf Session-ID und Datum
            from datetime import datetime
            date_str = datetime.now().strftime("%Y%m%d")
            session_short = self.session_id[-8:] if self.session_id else "unknown"
            filename = f"chat_{date_str}_{session_short}.json"
            filepath = os.path.join(conversations_dir, filename)
            
            # Speichere Chat-Messages
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(self.chat_messages, f, indent=2, ensure_ascii=False)
            
            logger.debug(f"Conversation auto-gespeichert: {filename}")
            
        except Exception as e:
            logger.debug(f"Auto-Save-Fehler f√ºr {self.window_id}: {e}")
    
    def send_chat_message(self, content: str):
        """Sendet eine Chat-Nachricht"""
        user_message = ChatMessage(
            sender_id=self.window_id,
            role='user',
            content=content,
            chat_id=self.window_id
        )
        
        # Nachricht zu lokalen Messages hinzuf√ºgen
        self._handle_chat_message(user_message)
        
        # Status-Update senden
        status_msg = StatusMessage(self.window_id, "Sende Nachricht...")
        self._handle_status_update(status_msg)
        
        # Backend-Anfrage in separatem Thread
        threading.Thread(
            target=self._send_to_backend,
            args=(content,),
            daemon=True
        ).start()
    
    def _send_to_backend(self, message: str):
        """Sendet Nachricht an Backend (l√§uft in separatem Thread)"""
        try:
            # Prim√§r: Backend-API verwenden (empfohlen)
            # Das Backend entscheidet, ob UDS3 oder andere Methoden verwendet werden
            
            # Session erstellen falls nicht vorhanden
            if not hasattr(self, 'session_id') or not self.session_id:
                if not self._create_api_session():
                    self._send_error_response("‚ùå Keine API-Session verf√ºgbar")
                    return
            
            # Bestimme Modus
            mode_key = "veritas"  # Standard
            
            if hasattr(self, 'current_question_mode') and self.current_question_mode:
                mode_key = self.current_question_mode.get('key', 'veritas')
                logger.info(f"üîÑ Verwende Modus: '{mode_key}'")
            
            # Check if streaming is available and initialized
            use_streaming = STREAMING_AVAILABLE and hasattr(self, 'streaming_service') and self.streaming_service is not None
            
            # If streaming available, use streaming endpoint
            if use_streaming:
                logger.info(f"üöÄ Using Streaming Query for: {message[:50]}...")
                
                # üÜï Bereite conversation_history vor (letzte 5 Nachrichten f√ºr Kontext)
                conversation_history = None
                if hasattr(self, 'chat_messages') and len(self.chat_messages) > 0:
                    # Nehme die letzten 5 Nachrichten (max 10 wegen User+Assistant Paaren)
                    recent_messages = self.chat_messages[-10:]
                    conversation_history = [
                        {
                            'role': msg.get('role', 'user'),
                            'content': msg.get('content', '')
                        }
                        for msg in recent_messages
                        if msg.get('role') in ['user', 'assistant']
                    ]
                    logger.info(f"üìö Sende {len(conversation_history)} Nachrichten als Kontext")
                
                result = self.streaming_service.start_streaming_query(
                    query=message,
                    session_id=self.session_id,
                    enable_progress=True,
                    enable_intermediate=True,
                    enable_thinking=True,
                    conversation_history=conversation_history
                )
                
                if result.get('success'):
                    logger.info(f"‚úÖ Streaming started: {result.get('stream_session_id')}")
                    return  # Progress updates will come via streaming messages
                else:
                    logger.warning(f"‚ö†Ô∏è Streaming failed: {result.get('error')}, falling back to regular query")
                    # Fall through to regular query
            
            # Erstelle einfache Backend-konforme Request (Dict mit 'query' statt 'question')
            request_payload = {
                "query": message,  # Backend erwartet 'query' nicht 'question'
                "session_id": self.session_id,
                "model": getattr(self, 'llm_var', tk.StringVar(value='llama3:latest')).get(),
                "temperature": getattr(self, 'temperature_var', tk.DoubleVar(value=0.7)).get(),
                "max_tokens": getattr(self, 'max_tokens_var', tk.IntVar(value=500)).get() if hasattr(self, 'max_tokens_var') else 500,
                "mode": mode_key,
                "enable_streaming": False  # Fallback non-streaming mode
            }
            
            # Sende an v2/query Endpoint
            logger.info(f"üöÄ Sende Query an /v2/query (Modus: {mode_key})")
            logger.debug(f"Payload: {request_payload}")
            
            api_response = requests.post(
                f"{API_BASE_URL}/v2/query",
                json=request_payload,
                timeout=60
            )
            
            if api_response.status_code == 200:
                response_data = api_response.json()
                
                # Backend gibt 'response_text' zur√ºck
                response_text = response_data.get('response_text', 'Keine Antwort erhalten.')
                
                # Erweiterte Informationen hinzuf√ºgen
                additional_info = []
                
                # Confidence Score
                confidence_score = response_data.get('confidence_score', 0.0)
                if confidence_score > 0:
                    additional_info.append(f"üéØ Confidence: {confidence_score:.1%}")
                
                # Quellen
                sources = response_data.get('sources', [])
                if sources:
                    additional_info.append(f"üìö {len(sources)} Quellen")
                
                # Processing-Metadaten
                metadata = response_data.get('processing_metadata', {})
                processing_time = metadata.get('processing_time', 0)
                if processing_time > 0:
                    additional_info.append(f"‚ö° {processing_time:.2f}s")
                
                # Agent/Worker-Ergebnisse
                worker_results = response_data.get('worker_results', {})
                if worker_results:
                    additional_info.append(f"ü§ñ {len(worker_results)} Agents")
                
                # Zus√§tzliche Infos anh√§ngen
                if additional_info:
                    response_text += f"\n\nüí° {' | '.join(additional_info)}"
                
                # Follow-up Vorschl√§ge
                suggestions = response_data.get('follow_up_suggestions', [])
                if suggestions:
                    response_text += f"\n\nüîç **Vorschl√§ge:**\n" + "\n".join([f"‚Ä¢ {s}" for s in suggestions[:3]])
                
                # Backend-Response-Message erstellen
                response_msg = QueueMessage(
                    MessageType.BACKEND_RESPONSE,
                    "Backend API",
                    datetime.now().timestamp(),
                    {
                        'content': response_text,
                        'sources': sources,
                        'confidence_score': confidence_score,
                        'suggestions': suggestions,
                        'worker_results': worker_results,
                        'metadata': metadata,
                        'session_id': response_data.get('session_id', self.session_id),
                        'processing_time': processing_time
                    }
                )
                
                # Response an korrekte Queue senden (ChatWindowBase.queue)
                self.queue.put(response_msg)
                logger.info(f"‚úÖ Backend Response: {len(response_text)} Zeichen, Confidence: {confidence_score:.2%}")
                
                # Upload-Dateien nach erfolgreichem Senden zur√ºcksetzen
                if hasattr(self, 'uploaded_files'):
                    self._clear_all_attachments()
                return
                    
            else:
                # HTTP-Fehler behandeln
                error_msg = f"HTTP-Fehler {api_response.status_code}"
                try:
                    error_data = api_response.json()
                    if 'detail' in error_data:
                        error_msg = f"{error_msg}: {error_data['detail']}"
                except:
                    pass
                
                self._send_error_response(f"‚ùå {error_msg}")
                logger.error(f"Backend HTTP Fehler: {error_msg}")
                return
        
        except requests.exceptions.Timeout:
            error_msg = "‚è±Ô∏è Timeout: Server antwortet nicht (30s)"
            logger.error(f"API Timeout: {error_msg}")
            self._send_error_response(error_msg)
            
        except requests.exceptions.ConnectionError:
            error_msg = "üîå Verbindungsfehler: Server nicht erreichbar"
            logger.error(f"API Connection Error: {error_msg}")
            self._send_error_response(error_msg)
            
        except requests.exceptions.RequestException as e:
            error_msg = f"üì° Request-Fehler: {str(e)}"
            logger.error(f"API Request Error: {e}")
            self._send_error_response(error_msg)
            
        except Exception as e:
            error_msg = f"üí• Unerwarteter Fehler: {str(e)}"
            logger.error(f"Backend-Fehler: {e}")
            self._send_error_response(error_msg)
    
    def _create_api_session(self) -> bool:
        """Erstellt eine neue API-Session. Gibt True zur√ºck wenn erfolgreich."""
        try:
            payload = {
                "user_id": f"veritas_user_{self.window_id}"
            }
            
            response = requests.post(
                f"{API_BASE_URL}/start_session",
                json=payload,
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                self.session_id = data.get("session_id")
                logger.info(f"API-Session erstellt f√ºr {self.window_id}: {self.session_id}")
                return True
            else:
                logger.error(f"Session-Erstellung fehlgeschlagen: HTTP {response.status_code} - {response.text}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Session-Erstellung - Verbindungsfehler: {e}")
            return False
        except Exception as e:
            logger.error(f"Session-Erstellung - Unerwarteter Fehler: {e}")
            return False
    
    def _send_error_response(self, error_message: str):
        """Sendet eine Fehler-Nachricht an die eigene Queue"""
        error_msg = QueueMessage(
            MessageType.ERROR_MESSAGE,
            "Backend",
            datetime.now().timestamp(),
            {'content': error_message}
        )
        self.queue.put(error_msg)
    
    def _add_feedback_widget(self, message_id: str, message_data: Dict):
        """F√ºgt ein Feedback-Widget f√ºr eine Assistant-Nachricht hinzu"""
        try:
            feedback_widget = MessageFeedbackWidget(
                self.chat_text,
                message_data,
                save_callback=self._save_feedback
            )
            feedback_widget.create_feedback_buttons()
            self.feedback_widgets[message_id] = feedback_widget
            self.last_assistant_message_id = message_id
            logger.debug(f"Feedback-Widget f√ºr {message_id} hinzugef√ºgt")
        except Exception as e:
            logger.error(f"Fehler beim Hinzuf√ºgen des Feedback-Widgets: {e}")
    
    def _save_feedback(self, message_id: str, feedback_data: Dict):
        """Speichert Feedback f√ºr eine Nachricht"""
        try:
            # Feedback in den Nachrichtenmetadaten speichern
            for message in self.chat_messages:
                if message.get('id') == message_id:
                    if 'metadata' not in message:
                        message['metadata'] = {}
                    if 'user_feedback' not in message['metadata']:
                        message['metadata']['user_feedback'] = []
                    
                    feedback_entry = {
                        **feedback_data,
                        'timestamp': datetime.now().isoformat()
                    }
                    message['metadata']['user_feedback'].append(feedback_entry)
                    logger.info(f"Feedback f√ºr {message_id} gespeichert: {feedback_data.get('rating', 'Kommentar')}")
                    break
        except Exception as e:
            logger.error(f"Fehler beim Speichern des Feedbacks: {e}")
    
    def _repeat_last_question(self):
        """Wiederholt die letzte Benutzerfrage"""
        try:
            # Finde die letzte Benutzernachricht
            last_user_message = None
            for message in reversed(self.chat_messages):
                if message.get('role') == 'user':
                    last_user_message = message.get('content')
                    break
            
            if last_user_message:
                self.send_chat_message(last_user_message)
                logger.info("Letzte Frage wiederholt")
            else:
                logger.warning("Keine vorherige Benutzerfrage gefunden")
        except Exception as e:
            logger.error(f"Fehler beim Wiederholen der Frage: {e}")
    
    @abstractmethod
    def update_chat_display(self):
        """Aktualisiert die Chat-Anzeige - muss von Subklassen implementiert werden"""
        pass
    
    def transfer_to_window(self, target_window: 'ChatWindowBase'):
        """√úbertr√§gt Chat-Inhalt zu einem anderen Fenster"""
        target_window.chat_messages.extend(self.chat_messages)
        if target_window.window and hasattr(target_window.window, 'winfo_exists') and target_window.window.winfo_exists():
            target_window.window.after(0, target_window._safe_update_chat_display)
        logger.info(f"Chat-Inhalt von {self.window_id} zu {target_window.window_id} √ºbertragen")
    
    def close_window(self):
        """Schlie√üt das Fenster thread-sicher"""
        try:
            self.thread_manager.remove_thread(self.window_id)
            if self.window and hasattr(self.window, 'winfo_exists') and self.window.winfo_exists():
                self.window.destroy()
            logger.info(f"ChatWindow {self.window_id} geschlossen")
        except tk.TclError:
            logger.debug(f"ChatWindow {self.window_id} bereits geschlossen")
        except Exception as e:
            logger.error(f"Fehler beim Schlie√üen von {self.window_id}: {e}")
    
    # === GEMEINSAME GUI-ERSTELLUNGSMETHODEN ===
    
    def _create_chat_display(self, parent, height=20):
        """Erstellt die Chat-Anzeige (gemeinsam f√ºr alle Windows)"""
        self.chat_text = scrolledtext.ScrolledText(
            parent,
            wrap=tk.WORD,
            height=height,
            font=('Segoe UI', 10),
            bg='#ffffff',
            fg='#333333',
            selectbackground='#0078d4',
            selectforeground='white'
        )
        self.chat_text.pack(fill=tk.BOTH, expand=True, pady=(0, 5))
        self.chat_text.config(state=tk.DISABLED)
        
        # Text-Tags f√ºr moderne Formatierung
        self.chat_text.tag_configure("user", foreground="#0066CC", font=('Segoe UI', 10, 'bold'))
        self.chat_text.tag_configure("assistant", foreground="#1a1a1a", font=('Segoe UI', 10))
        self.chat_text.tag_configure("assistant_main", foreground="#000000", font=('Segoe UI', 11))
        self.chat_text.tag_configure("system", foreground="#666666", font=('Segoe UI', 9, 'italic'))
        self.chat_text.tag_configure("timestamp", foreground="#999999", font=('Segoe UI', 8))
        self.chat_text.tag_configure("source", foreground="#4a90e2", font=('Segoe UI', 9))
        self.chat_text.tag_configure("agent", foreground="#e67e22", font=('Segoe UI', 9))
        self.chat_text.tag_configure("metadata", foreground="#7f8c8d", font=('Segoe UI', 8, 'italic'))
        self.chat_text.tag_configure("header", foreground="#2c3e50", font=('Segoe UI', 10, 'bold'))
        self.chat_text.tag_configure("clickable", foreground="#0066CC", font=('Segoe UI', 9, 'underline'), underline=True)
        self.chat_text.tag_configure("clickable_link", foreground="#0066CC", font=('Segoe UI', 9, 'underline'), underline=True)
        self.chat_text.tag_configure("collapsed", foreground="#95a5a6", font=('Segoe UI', 9))
        self.chat_text.tag_configure("confidence_high", foreground="#27ae60", font=('Segoe UI', 9, 'bold'))
        self.chat_text.tag_configure("confidence_med", foreground="#f39c12", font=('Segoe UI', 9, 'bold'))
        self.chat_text.tag_configure("confidence_low", foreground="#e74c3c", font=('Segoe UI', 9, 'bold'))
        
        # ‚ú® NEW: Sprechblasen-Design (Tag-basiert, KEIN Canvas)
        # User-Message Bubble (rechtsb√ºndig)
        self.chat_text.tag_configure("user_bubble", 
                                     background='#E3F2FD',       # Hellblau
                                     relief='solid', 
                                     borderwidth=1,
                                     lmargin1=150,               # Rechtsb√ºndig (linker Margin)
                                     lmargin2=150,               # Einzug f√ºr mehrzeiligen Text
                                     rmargin=10,                 # Rechter Rand
                                     spacing1=8,                 # Padding oben
                                     spacing3=8,                 # Padding unten
                                     font=('Segoe UI', 10))
        
        # User-Metadata (Attachments + Timestamp oberhalb Bubble)
        self.chat_text.tag_configure("user_metadata", 
                                     font=('Segoe UI', 8), 
                                     foreground='#666',
                                     lmargin1=150,               # Rechtsb√ºndig wie Bubble
                                     spacing3=2)                 # Kleiner Abstand zur Bubble
        
        # Assistant-Message Bubble (linksb√ºndig)
        self.chat_text.tag_configure("assistant_bubble", 
                                     background='#F5F5F5',       # Hellgrau
                                     relief='flat',              # Kein Rahmen f√ºr Assistant
                                     lmargin1=10,                # Linksb√ºndig
                                     lmargin2=10,
                                     rmargin=150,                # Rechter Margin (Platz f√ºr User-Bubbles)
                                     spacing1=8,
                                     spacing3=8,
                                     font=('Segoe UI', 10))
        
        # Message-Separator
        self.chat_text.tag_configure("message_separator", 
                                     spacing1=10,                # Abstand zwischen Messages
                                     spacing3=10)
        
        # Attachment-Link (klickbar)
        self.chat_text.tag_configure("attachment_link", 
                                     font=('Segoe UI', 8), 
                                     foreground='#0066CC', 
                                     underline=True)
        
        # Metriken-Compact (Inline horizontal)
        self.chat_text.tag_configure("metrics_compact", 
                                     font=('Segoe UI', 8), 
                                     foreground='#666',
                                     spacing1=2,
                                     spacing3=5)
        
        # Processing-Placeholder (pulsierend)
        self.chat_text.tag_configure("processing_placeholder", 
                                     font=('Segoe UI', 10, 'italic'), 
                                     foreground='#999')
        
        # Confidence-Badges mit Background-Colors
        self.chat_text.tag_configure("confidence_badge_high", 
                                     font=('Segoe UI', 8, 'bold'), 
                                     foreground='#ffffff',
                                     background='#27ae60')  # Gr√ºn
        self.chat_text.tag_configure("confidence_badge_med", 
                                     font=('Segoe UI', 8, 'bold'), 
                                     foreground='#ffffff',
                                     background='#f39c12')  # Orange
        self.chat_text.tag_configure("confidence_badge_low", 
                                     font=('Segoe UI', 8, 'bold'), 
                                     foreground='#ffffff',
                                     background='#e74c3c')  # Rot
        
        # Markdown-Tags
        self.chat_text.tag_configure("md_bold", font=('Segoe UI', 10, 'bold'))
        self.chat_text.tag_configure("md_italic", font=('Segoe UI', 10, 'italic'))
        self.chat_text.tag_configure("md_code", font=('Consolas', 9), background="#f0f0f0", foreground="#c7254e")
        self.chat_text.tag_configure("md_heading1", font=('Segoe UI', 14, 'bold'), foreground="#2c3e50")
        self.chat_text.tag_configure("md_heading2", font=('Segoe UI', 12, 'bold'), foreground="#34495e")
        self.chat_text.tag_configure("md_heading3", font=('Segoe UI', 11, 'bold'), foreground="#7f8c8d")
        self.chat_text.tag_configure("md_list_item", foreground="#555555")
        self.chat_text.tag_configure("md_quote", font=('Segoe UI', 10, 'italic'), foreground="#7f8c8d", lmargin1=20, lmargin2=20)
        
        # Link-Styling (cursor wird √ºber Bindings gesteuert, nicht tag_configure)
        self.chat_text.tag_configure("clickable_link", foreground="#0066CC", underline=True)
        # Cursor-Effekt √ºber Events (tag_configure unterst√ºtzt KEIN cursor)
        self.chat_text.tag_bind("clickable_link", "<Enter>", lambda e: self.chat_text.config(cursor="hand2"))
        self.chat_text.tag_bind("clickable_link", "<Leave>", lambda e: self.chat_text.config(cursor=""))
    
    def _create_input_area(self, parent, include_attachments=True):
        """Erstellt den Eingabebereich (gemeinsam f√ºr alle Windows)"""
        input_frame = ttk.Frame(parent)
        input_frame.pack(fill=tk.X, pady=(5, 0))
        
        if include_attachments:
            # Datei-Anhang Bereich (√ºber der Eingabe)
            attachment_frame = ttk.Frame(input_frame)
            attachment_frame.pack(fill=tk.X, pady=(0, 5))
            
            ttk.Button(attachment_frame, text="üìé Datei hinzuf√ºgen", 
                      command=self._upload_file, width=20).pack(side=tk.LEFT)
            
            # Bereich f√ºr angeh√§ngte Dateien
            self.attachments_display = ttk.Frame(attachment_frame)
            self.attachments_display.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(10, 0))
        
        # Eingabe-Text
        self.input_text = tk.Text(
            input_frame,
            height=3,
            wrap=tk.WORD,
            font=('Segoe UI', 10),
            bg='#ffffff',
            fg='#333333',
            selectbackground='#0078d4',
            selectforeground='white'
        )
        self.input_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        
        # Send-Button
        self.send_button = ttk.Button(
            input_frame,
            text="üì§ Senden",
            command=self._send_message,
            width=12
        )
        self.send_button.pack(side=tk.RIGHT, anchor=tk.N)
        
        return input_frame
    
    def _create_settings_bar(self, parent, compact=False):
        """Erstellt die unscheinbare Einstellungsleiste"""
        settings_frame = ttk.Frame(parent, relief=tk.FLAT)
        settings_frame.pack(fill=tk.X, pady=(3, 0))
        
        # Frage-Modus Auswahl (vor LLM-Auswahl)
        ttk.Label(settings_frame, text="üìã", font=('Segoe UI', 8)).pack(side=tk.LEFT, padx=(0, 2))
        
        self.mode_var = tk.StringVar(value="veritas")
        
        # Dynamisch Frage-Modi laden mit Fallback
        logger.info("üîÑ Lade Frage-Modi f√ºr GUI...")
        try:
            available_question_methods = self.get_available_question_methods()
            mode_values = [method['display'] for method in available_question_methods]
            self.question_methods_data = {method['display']: method for method in available_question_methods}
            logger.info(f"üìã GUI: {len(mode_values)} Modi geladen: {mode_values}")
        except Exception as e:
            logger.error(f"‚ùå Fehler beim Laden der Modi: {e}")
            # Fallback-Modi
            available_question_methods = [
                {'key': 'veritas', 'display': 'Standard RAG', 'endpoints': ['/ask'], 'description': 'Standard Retrieval-Augmented Generation'},
                {'key': 'vpb', 'display': 'VPB Verwaltung', 'endpoints': ['/vpb/ask'], 'description': 'Verwaltungsprozess-Analyse'}
            ]
            mode_values = [method['display'] for method in available_question_methods]
            self.question_methods_data = {method['display']: method for method in available_question_methods}
        
        self.mode_combo = ttk.Combobox(
            settings_frame,
            textvariable=self.mode_var,
            values=mode_values,
            state="readonly",
            width=12,
            font=('Segoe UI', 8)
        )
        self.mode_combo.pack(side=tk.LEFT, padx=(0, 10))
        self.mode_combo.bind('<<ComboboxSelected>>', self.on_mode_change)
        
        # Setze Standard-Wert
        if mode_values:
            self.mode_combo.set(mode_values[0])
            # Setze aktuellen Modus f√ºr API-Anfragen
            if hasattr(self, 'question_methods_data') and mode_values[0] in self.question_methods_data:
                self.current_question_mode = self.question_methods_data[mode_values[0]]
            logger.info(f"üìã Standard-Modus gesetzt: {mode_values[0]}")
        else:
            logger.warning("‚ö†Ô∏è Keine Modi verf√ºgbar f√ºr Dropdown")
        
        # LLM-Modell (dynamisch vom API abgerufen)
        ttk.Label(settings_frame, text="ü§ñ", font=('Segoe UI', 8)).pack(side=tk.LEFT)
        
        # Lade verf√ºgbare Modelle vom API
        available_models = self._get_available_models()
        models = available_models if available_models else ["llama3.1:8b", "llama3.1:70b", "qwen2.5:7b", "mistral:7b"]
        
        # Initialisiere StringVar mit erstem verf√ºgbaren Modell
        default_model = models[0] if models else ""
        self.llm_var = tk.StringVar(value=default_model)
        
        # Nutze NUR die vom Backend verf√ºgbaren Modelle (keine Fake-Modelle mehr)
        self.llm_combo = ttk.Combobox(
            settings_frame, 
            textvariable=self.llm_var,
            values=models,
            width=12, 
            state="readonly",
            font=('Segoe UI', 8)
        )
        self.llm_combo.pack(side=tk.LEFT, padx=(3, 10))
        
        # Log das gesetzte Default-Modell
        if default_model:
            logger.info(f"üéØ Default-Modell gesetzt: {default_model}")
        
        # Event-Binding f√ºr automatisches Modell-Update
        self.llm_combo.bind('<Button-1>', self._on_dropdown_click)
        
        # Temperatur
        temp_icon = ttk.Label(settings_frame, text="üå°Ô∏è", font=('Segoe UI', 8))
        temp_icon.pack(side=tk.LEFT)
        if UI_COMPONENTS_AVAILABLE:
            Tooltip(temp_icon, 
                   "Temperature (0.0-1.0)\n"
                   "Niedrig (0.0-0.3): Pr√§zise, deterministische Antworten\n"
                   "Medium (0.4-0.7): Ausgewogen, Standard f√ºr RAG\n"
                   "Hoch (0.8-1.0): Kreativ, variabel\n\n"
                   "üí° Empfehlung: 0.7 f√ºr Verwaltungsfragen")
        
        self.temperature_var = tk.DoubleVar(value=0.7)
        self.temperature_scale = ttk.Scale(
            settings_frame, 
            from_=0.0, 
            to=1.0, 
            variable=self.temperature_var,
            orient=tk.HORIZONTAL,
            length=60
        )
        self.temperature_scale.pack(side=tk.LEFT, padx=(3, 5))
        self.temp_label = ttk.Label(settings_frame, text="0.7", font=('Segoe UI', 8))
        self.temp_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Max Tokens
        tokens_icon = ttk.Label(settings_frame, text="üìù", font=('Segoe UI', 8))
        tokens_icon.pack(side=tk.LEFT)
        if UI_COMPONENTS_AVAILABLE:
            Tooltip(tokens_icon,
                   "Max Tokens (100-2000)\n"
                   "L√§nge der HAUPT-Antwort (ohne Struktur-Anhang)\n\n"
                   "Kurz (100-800): Fakten, Paragraphen\n"
                   "Standard (800-1500): Verwaltungsantworten ‚úÖ\n"
                   "Ausf√ºhrlich (1500-2000): Komplexe Rechtsfragen\n\n"
                   "üí° Empfehlung: 1200 f√ºr Verwaltungsrecht\n"
                   "‚ÑπÔ∏è Backend f√ºgt +300 Tokens f√ºr Details/N√§chste Schritte/Vorschl√§ge hinzu\n"
                   "‚ö†Ô∏è Mehr Tokens = l√§ngere Antwortzeit")
        
        self.max_tokens_var = tk.IntVar(value=1200)  # ‚ú® ERH√ñHT von 500 auf 1200 f√ºr Verwaltungsrecht!
        self.max_tokens_spinbox = ttk.Spinbox(
            settings_frame,
            from_=100,
            to=2000,
            increment=100,
            width=5,
            textvariable=self.max_tokens_var,
            font=('Segoe UI', 8)
        )
        self.max_tokens_spinbox.pack(side=tk.LEFT, padx=(3, 3))
        self.tokens_label = ttk.Label(settings_frame, text="tok", font=('Segoe UI', 7))
        self.tokens_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Token-Counter & Antwortl√§ngen-Sch√§tzung (neue Zeile)
        self.token_info_label = ttk.Label(
            settings_frame,
            text="ÔøΩ ~900 W√∂rter",  # ‚ú® ANGEPASST: 1200 Tokens √ó 0.75 = 900 W√∂rter
            font=('Segoe UI', 7),
            foreground='#0088CC'  # ‚ú® Blau f√ºr Standard-Verwaltungsrecht
        )
        self.token_info_label.pack(side=tk.LEFT, padx=(5, 10))
        if UI_COMPONENTS_AVAILABLE:
            Tooltip(self.token_info_label,
                   "Gesch√§tzte Antwortl√§nge\n\n"
                   "Basierend auf max_tokens\n"
                   "1 Token ‚âà 0.75 W√∂rter (Deutsch)\n"
                   "1 Token ‚âà 4 Zeichen")
        
        # Top-p (Nucleus Sampling)
        topp_icon = ttk.Label(settings_frame, text="üé≤", font=('Segoe UI', 8))
        topp_icon.pack(side=tk.LEFT)
        if UI_COMPONENTS_AVAILABLE:
            Tooltip(topp_icon,
                   "Top-p / Nucleus Sampling (0.0-1.0)\n"
                   "Steuert Vielfalt der Token-Auswahl\n\n"
                   "Niedrig (0.5-0.7): Konservativ, fokussiert\n"
                   "Standard (0.8-0.9): Ausgewogen\n"
                   "Hoch (0.95-1.0): Maximal vielf√§ltig\n\n"
                   "üí° Empfehlung: 0.9 (Standard)\n"
                   "‚ÑπÔ∏è Arbeitet mit Temperature zusammen\n\n"
                   "üìö Mehr Infos: docs/LLM_PARAMETERS.md",
                   link_text="üìñ Hilfedokumentation √∂ffnen",
                   link_callback=lambda: self._open_help_docs("LLM_PARAMETERS"))
        
        self.top_p_var = tk.DoubleVar(value=0.9)
        self.top_p_scale = ttk.Scale(
            settings_frame,
            from_=0.0,
            to=1.0,
            variable=self.top_p_var,
            orient=tk.HORIZONTAL,
            length=60
        )
        self.top_p_scale.pack(side=tk.LEFT, padx=(3, 5))
        self.topp_label = ttk.Label(settings_frame, text="0.9", font=('Segoe UI', 8))
        self.topp_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Antwortzeit-Pr√§diktion (neue Zeile, nur im Main Window)
        if not compact:
            self.response_time_label = ttk.Label(
                settings_frame,
                text="‚è±Ô∏è ~3-5s",
                font=('Segoe UI', 7),
                foreground='#666666'
            )
            self.response_time_label.pack(side=tk.LEFT, padx=(5, 10))
            if UI_COMPONENTS_AVAILABLE:
                Tooltip(self.response_time_label,
                       "Gesch√§tzte Antwortzeit\n\n"
                       "Basierend auf:\n"
                       "‚Ä¢ Max Tokens\n"
                       "‚Ä¢ LLM-Modell\n"
                       "‚Ä¢ RAG-Overhead\n\n"
                       "‚ö†Ô∏è Tats√§chliche Zeit kann variieren")
        
        if not compact:
            # Suchtiefe (nur im Main Window)
            search_icon = ttk.Label(settings_frame, text="üîç", font=('Segoe UI', 8))
            search_icon.pack(side=tk.LEFT)
            if UI_COMPONENTS_AVAILABLE:
                Tooltip(search_icon,
                       "RAG Suchtiefe (1-20)\n"
                       "Anzahl der abzurufenden Dokumente\n\n"
                       "Niedrig (1-3): Schnell, pr√§zise\n"
                       "Standard (5-10): Ausgewogen\n"
                       "Hoch (10-20): Umfassend\n\n"
                       "üí° Empfehlung: 5 f√ºr typische Fragen")
            
            self.search_depth_var = tk.IntVar(value=5)
            ttk.Spinbox(settings_frame, from_=1, to=20, width=3, 
                       textvariable=self.search_depth_var, font=('Segoe UI', 8)).pack(side=tk.LEFT, padx=(3, 0))
        
        # Callbacks f√ºr Echtzeit-Updates
        self.temperature_scale.configure(command=self._update_temperature_label)
        self.top_p_scale.configure(command=self._update_topp_label)
        self.max_tokens_var.trace_add('write', self._update_tokens_label)
        
        # LLM-Modell-Wechsel aktualisiert auch Antwortzeit
        if hasattr(self, 'llm_var'):
            self.llm_var.trace_add('write', lambda *args: self._update_response_time_estimate() if hasattr(self, '_update_response_time_estimate') else None)
        
        # Initiale Aktualisierung der Sch√§tzungen
        self._update_tokens_label()
        if hasattr(self, '_update_response_time_estimate'):
            self._update_response_time_estimate()
        
        # Preset-Buttons (optional Feature)
        self._create_preset_buttons(parent)
    
    def _create_preset_buttons(self, parent):
        """Erstellt Preset-Buttons f√ºr schnelle Parameter-Konfiguration"""
        preset_frame = ttk.Frame(parent)
        preset_frame.pack(fill=tk.X, padx=5, pady=3)
        
        # Label
        preset_label = ttk.Label(
            preset_frame,
            text="Presets:",
            font=('Segoe UI', 8, 'bold'),
            foreground='#555555'
        )
        preset_label.pack(side=tk.LEFT, padx=(0, 8))
        
        # Preset-Definitionen: (Label, Temp, Tokens, Top-p, Tooltip)
        # ‚ú® ANGEPASST F√úR VERWALTUNGSRECHT (h√∂here Token-Counts!)
        presets = [
            ("‚öñÔ∏è Rechtsauskunft", 0.3, 800, 0.7, 
             "Pr√§zise Rechtsauskunft\n\nOptimal f√ºr:\n‚Ä¢ Gesetzestexte & Paragraphen\n‚Ä¢ Konkrete Rechtsfragen\n‚Ä¢ Beh√∂rdliche Bescheide\n\nTemp: 0.3 | Tokens: 800 | Top-p: 0.7\n\nüí° Tipp: F√ºr kurze, faktenbasierte Antworten"),
            
            ("üìò Standard", 0.6, 1200, 0.85,
             "Standard-Verwaltungsantwort\n\nOptimal f√ºr:\n‚Ä¢ Typische Verwaltungsfragen\n‚Ä¢ Verfahrensabl√§ufe\n‚Ä¢ Antragsberatung\n\nTemp: 0.6 | Tokens: 1200 | Top-p: 0.85\n\nüí° Tipp: IDEAL f√ºr Verwaltungsrecht"),
            
            ("ÔøΩ Ausf√ºhrlich", 0.5, 1800, 0.8,
             "Ausf√ºhrliche Rechtsanalyse\n\nOptimal f√ºr:\n‚Ä¢ Komplexe Rechtsfragen\n‚Ä¢ Mehrere Rechtsgebiete\n‚Ä¢ Detaillierte Verfahrenserkl√§rungen\n\nTemp: 0.5 | Tokens: 1800 | Top-p: 0.8\n\nüí° Tipp: F√ºr umfassende Beratung"),
            
            ("üé® B√ºrgerfreundlich", 0.7, 1000, 0.9,
             "B√ºrgerfreundliche Formulierung\n\nOptimal f√ºr:\n‚Ä¢ Verst√§ndliche Erkl√§rungen\n‚Ä¢ Umformulierung von Amtsdeutsch\n‚Ä¢ Mehrere Beispiele\n\nTemp: 0.7 | Tokens: 1000 | Top-p: 0.9\n\nüí° Tipp: F√ºr B√ºrgerkommunikation")
        ]
        
        # Buttons erstellen
        for label, temp, tokens, topp, tooltip_text in presets:
            btn = ttk.Button(
                preset_frame,
                text=label,
                command=lambda t=temp, tk=tokens, p=topp, l=label: self._apply_preset(t, tk, p, l),
                width=14
            )
            btn.pack(side=tk.LEFT, padx=2)
            
            # Tooltip hinzuf√ºgen
            if UI_COMPONENTS_AVAILABLE:
                Tooltip(btn, tooltip_text)
    
    def _apply_preset(self, temperature, max_tokens, top_p, preset_name):
        """Wendet ein Parameter-Preset an"""
        try:
            # Parameter setzen
            self.temperature_var.set(temperature)
            self.max_tokens_var.set(max_tokens)
            self.top_p_var.set(top_p)
            
            # Labels aktualisieren
            self._update_temperature_label(temperature)
            self._update_topp_label(top_p)
            self._update_tokens_label()
            
            # System-Message im Chat (mit Fallback falls Methode nicht verf√ºgbar)
            preset_msg = f"üéõÔ∏è Preset angewandt: {preset_name} (Temp={temperature}, Tokens={max_tokens}, Top-p={top_p})"
            if hasattr(self, 'add_system_message') and callable(self.add_system_message):
                self.add_system_message(preset_msg)
            else:
                logger.info(preset_msg)
            
            # Log
            logger.info(f"Preset angewandt: {preset_name} | T={temperature}, Tokens={max_tokens}, p={top_p}")
            
        except Exception as e:
            logger.error(f"Fehler beim Anwenden des Presets '{preset_name}': {e}")
            if hasattr(self, 'add_system_message') and callable(self.add_system_message):
                try:
                    self.add_system_message(f"‚ùå Fehler beim Anwenden des Presets: {e}")
                except:
                    pass  # Verhindert Endlosschleife
    
    def _create_status_bar(self, parent, show_uds3=True):
        """Erstellt die Status-Bar"""
        status_frame = ttk.Frame(parent)
        status_frame.pack(fill=tk.X, pady=(5, 0))
        
        self.status_var = tk.StringVar()
        status_text = "Bereit - Hauptfenster" if self.is_main_window else f"Bereit - {self.window_id}"
        self.status_var.set(status_text)
        
        status_label = ttk.Label(
            status_frame,
            textvariable=self.status_var,
            font=('Segoe UI', 8),
            foreground='#666666'
        )
        status_label.pack(side=tk.LEFT)
        
        # UDS3 ist im Frontend nicht mehr relevant - Backend verwaltet alle Datenoperationen
    
    # === GEMEINSAME DATEI-MANAGEMENT METHODEN ===
    
    def _upload_file(self):
        """Datei f√ºr Kontext hochladen"""
        filetypes = [
            ("PDF-Dateien", "*.pdf"),
            ("Word-Dokumente", "*.docx *.doc"),
            ("Text-Dateien", "*.txt"),
            ("Markdown-Dateien", "*.md"),
            ("Alle Dateien", "*.*")
        ]
        
        filename = filedialog.askopenfilename(
            title="Datei f√ºr Kontext ausw√§hlen",
            filetypes=filetypes
        )
        
        if filename:
            try:
                import os
                file_name = os.path.basename(filename)
                
                if not hasattr(self, 'uploaded_files'):
                    self.uploaded_files = []
                self.uploaded_files.append(filename)
                
                # Datei-Button erstellen (nur wenn attachments_display existiert)
                if hasattr(self, 'attachments_display'):
                    self._add_attachment_button(file_name, filename)
                
                logger.info(f"Datei f√ºr Upload ausgew√§hlt: {file_name}")
                
            except Exception as e:
                messagebox.showerror("Fehler", f"Datei konnte nicht gelesen werden: {e}")
                logger.error(f"Datei-Upload Fehler: {e}")
    
    def _add_attachment_button(self, file_name, file_path):
        """F√ºgt einen Button f√ºr eine angeh√§ngte Datei hinzu"""
        display_name = file_name if len(file_name) <= 20 else file_name[:17] + "..."
        
        file_button = ttk.Button(
            self.attachments_display,
            text=f"üìÑ {display_name} ‚ùå",
            command=lambda: self._remove_attachment(file_path),
            width=25
        )
        file_button.pack(side=tk.LEFT, padx=(0, 5))
        
        if not hasattr(self, 'attachment_buttons'):
            self.attachment_buttons = {}
        self.attachment_buttons[file_path] = file_button
    
    def _remove_attachment(self, file_path):
        """Entfernt eine angeh√§ngte Datei"""
        try:
            if hasattr(self, 'uploaded_files') and file_path in self.uploaded_files:
                self.uploaded_files.remove(file_path)
            
            if hasattr(self, 'attachment_buttons') and file_path in self.attachment_buttons:
                self.attachment_buttons[file_path].destroy()
                del self.attachment_buttons[file_path]
            
            import os
            logger.info(f"Datei-Anhang entfernt: {os.path.basename(file_path)}")
            
        except Exception as e:
            logger.error(f"Fehler beim Entfernen des Anhangs: {e}")
    
    def _clear_all_attachments(self):
        """Entfernt alle Datei-Anh√§nge"""
        try:
            if hasattr(self, 'uploaded_files'):
                self.uploaded_files = []
            
            if hasattr(self, 'attachment_buttons'):
                for button in self.attachment_buttons.values():
                    button.destroy()
                self.attachment_buttons = {}
                
        except Exception as e:
            logger.error(f"Fehler beim L√∂schen aller Anh√§nge: {e}")
    
    # === GEMEINSAME ACTION METHODEN ===
    
    def _update_temperature_label(self, value):
        """Aktualisiert das Temperatur-Label"""
        try:
            temp_value = float(value)
            if hasattr(self, 'temp_label'):
                self.temp_label.config(text=f"{temp_value:.1f}")
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren des Temperatur-Labels: {e}")
    
    def _update_topp_label(self, value):
        """Aktualisiert das Top-p-Label"""
        try:
            topp_value = float(value)
            if hasattr(self, 'topp_label'):
                self.topp_label.config(text=f"{topp_value:.2f}")
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren des Top-p-Labels: {e}")
    
    def _update_tokens_label(self, *args):
        """Aktualisiert das Max-Tokens-Label und Token-Counter bei Spinbox-√Ñnderung"""
        try:
            tokens = self.max_tokens_var.get()
            
            # Token ‚Üí W√∂rter (Deutsch: 1 Token ‚âà 0.75 W√∂rter)
            estimated_words = int(tokens * 0.75)
            
            # Token ‚Üí Zeichen (Deutsch: 1 Token ‚âà 4 Zeichen)
            estimated_chars = int(tokens * 4)
            
            # Token-Counter aktualisieren
            if hasattr(self, 'token_info_label'):
                # ‚ú® ANGEPASST F√úR VERWALTUNGSRECHT (h√∂here Schwellenwerte!)
                # Verwaltungsrechtliche Antworten sind oft komplex und ausf√ºhrlich
                if tokens < 1000:
                    color = '#00AA00'  # Gr√ºn: Kurz/Normal (100-999 Tokens)
                    indicator = 'üí¨'
                elif tokens < 1500:
                    color = '#0088CC'  # Blau: Standard (1000-1499 Tokens) - IDEAL f√ºr Verwaltung
                    indicator = 'üìò'
                elif tokens < 2000:
                    color = '#FF8800'  # Orange: Ausf√ºhrlich (1500-1999 Tokens)
                    indicator = 'üìù'
                else:
                    color = '#CC6600'  # Dunkelorange: Sehr ausf√ºhrlich (2000+ Tokens)
                    indicator = 'üìö'
                
                self.token_info_label.config(
                    text=f"{indicator} ~{estimated_words} W√∂rter",
                    foreground=color
                )
            
            # Auch Antwortzeit-Sch√§tzung aktualisieren (falls vorhanden)
            if hasattr(self, '_update_response_time_estimate'):
                self._update_response_time_estimate()
                
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren des Tokens-Labels: {e}")
    
    def _estimate_response_time(self):
        """Sch√§tzt die Antwortzeit basierend auf Token-Count und Modell"""
        try:
            # Benchmark-Daten (Tokens/Sekunde f√ºr verschiedene Modelle)
            MODEL_BENCHMARKS = {
                'llama3:latest': 150,
                'llama3.1:8b': 120,
                'llama3.2:latest': 140,
                'phi3:latest': 200,
                'mixtral:latest': 80,
                'codellama:latest': 130,
                'gemma2:latest': 160,
                'qwen2.5:latest': 145
            }
            
            max_tokens = self.max_tokens_var.get()
            model = self.llm_var.get() if hasattr(self, 'llm_var') else 'llama3:latest'
            
            # Tokens/Sekunde f√ºr aktuelles Modell (Default: 120)
            tokens_per_second = MODEL_BENCHMARKS.get(model, 120)
            
            # Base-Zeit (LLM-Generation)
            generation_time = max_tokens / tokens_per_second
            
            # Overhead (RAG-Retrieval, Agent-Processing, etc.)
            overhead = 1.5  # Sekunden
            
            # Gesamt-Zeit
            total_time = generation_time + overhead
            
            # Range (¬±20% Unsicherheit)
            min_time = total_time * 0.8
            max_time = total_time * 1.2
            
            return min_time, max_time
            
        except Exception as e:
            logger.error(f"Fehler bei Antwortzeit-Sch√§tzung: {e}")
            return 2.0, 6.0  # Fallback
    
    def _update_response_time_estimate(self):
        """Aktualisiert die Antwortzeit-Sch√§tzung im Label"""
        try:
            if hasattr(self, 'response_time_label'):
                min_time, max_time = self._estimate_response_time()
                
                # Farbcodierung
                avg_time = (min_time + max_time) / 2
                if avg_time < 4:
                    color = '#00AA00'  # Gr√ºn: Schnell
                    indicator = '‚ö°'
                elif avg_time < 8:
                    color = '#FF8800'  # Orange: Mittel
                    indicator = '‚è±Ô∏è'
                else:
                    color = '#DD0000'  # Rot: Langsam
                    indicator = 'üêå'
                
                self.response_time_label.config(
                    text=f"{indicator} ~{min_time:.0f}-{max_time:.0f}s",
                    foreground=color
                )
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren der Antwortzeit-Sch√§tzung: {e}")
    
    def _open_help_docs(self, doc_name):
        """√ñffnet Hilfedokumentation"""
        try:
            import webbrowser
            import os
            
            # Pfad zur Dokumentation
            docs_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'docs', f'{doc_name}.md')
            
            if os.path.exists(docs_path):
                # √ñffne Markdown-Datei im Standard-Editor
                if sys.platform == 'win32':
                    os.startfile(docs_path)
                elif sys.platform == 'darwin':  # macOS
                    os.system(f'open "{docs_path}"')
                else:  # Linux
                    os.system(f'xdg-open "{docs_path}"')
                logger.info(f"üìñ Hilfedokumentation ge√∂ffnet: {doc_name}.md")
            else:
                # Fallback: √ñffne Online-Dokumentation
                messagebox.showinfo(
                    "Dokumentation",
                    f"Hilfedokument '{doc_name}.md' wird erstellt.\n\n"
                    f"üí° LLM-Parameter Kurzreferenz:\n\n"
                    f"üå°Ô∏è Temperature (0.0-1.0):\n"
                    f"   Steuert Zuf√§lligkeit der Antworten\n"
                    f"   ‚Ä¢ 0.0-0.3: Pr√§zise, deterministisch\n"
                    f"   ‚Ä¢ 0.4-0.7: Ausgewogen (Standard)\n"
                    f"   ‚Ä¢ 0.8-1.0: Kreativ, variabel\n\n"
                    f"üìù Max Tokens (100-2000):\n"
                    f"   Maximale Antwortl√§nge\n"
                    f"   ‚Ä¢ 100-300: Kurz & knapp\n"
                    f"   ‚Ä¢ 400-800: Standard\n"
                    f"   ‚Ä¢ 800-2000: Ausf√ºhrlich\n\n"
                    f"üé≤ Top-p (0.0-1.0):\n"
                    f"   Nucleus Sampling - Vielfalt der Wortwahl\n"
                    f"   ‚Ä¢ 0.5-0.7: Konservativ\n"
                    f"   ‚Ä¢ 0.8-0.9: Ausgewogen (Standard)\n"
                    f"   ‚Ä¢ 0.95-1.0: Maximal vielf√§ltig"
                )
        except Exception as e:
            logger.error(f"‚ùå Fehler beim √ñffnen der Hilfedokumentation: {e}")
            messagebox.showerror("Fehler", f"Dokumentation konnte nicht ge√∂ffnet werden: {e}")
    
    def _get_available_models(self):
        """Ruft verf√ºgbare LLM-Modelle vom API ab"""
        # Pr√ºfe zuerst ob parent App Capabilities hat
        if self.parent and hasattr(self.parent, 'get_available_llm_models'):
            try:
                logger.info(f"üîç Versuche LLM-Modelle von Parent-App zu laden...")
                models = self.parent.get_available_llm_models()
                if models:
                    logger.info(f"‚úÖ {len(models)} LLM-Modelle aus Parent-App Capabilities")
                    return models
                else:
                    logger.info("‚ö†Ô∏è Parent returned no models - use fallback")
            except Exception as e:
                logger.error(f"‚ùå Parent-App Capabilities Fehler: {e}")
        else:
            if not self.parent:
                logger.info("‚ÑπÔ∏è Kein Parent verf√ºgbar - verwende API-Fallback")
            else:
                logger.info("‚ÑπÔ∏è Parent hat keine get_available_llm_models Methode")
        
        # Fallback: Direkter API-Call
        try:
            response = requests.get(f"{API_BASE_URL}/get_models", timeout=5)
            if response.status_code == 200:
                data = response.json()
                models = data.get('models', [])
                if models:
                    # Extrahiere nur die Modellnamen
                    model_names = [model.get('name', 'unknown') for model in models]
                    # Filter nur g√ºltige Namen
                    valid_models = [name for name in model_names if name != 'unknown']
                    if valid_models:
                        logger.info(f"‚úÖ {len(valid_models)} LLM-Modelle vom API abgerufen")
                        return valid_models
                    else:
                        logger.warning("‚ö†Ô∏è Alle Modelle haben 'unknown' Namen")
                        return None
                else:
                    logger.warning("‚ö†Ô∏è Keine Modelle vom API erhalten")
                    return None
            else:
                logger.warning(f"‚ö†Ô∏è API-Fehler beim Abrufen der Modelle: Status {response.status_code}")
                return None
        except Exception as e:
            logger.error(f"‚ùå Fehler beim API-Aufruf f√ºr Modelle: {e}")
            return None
    
    def _refresh_models(self):
        """Modelle neu laden und Combobox aktualisieren"""
        try:
            # Neue Modelle abrufen
            new_models = self._get_available_models()
            
            if new_models:
                # Combobox aktualisieren
                self.llm_combo['values'] = new_models
                
                # Aktuelles Modell pr√ºfen
                current_model = self.llm_var.get()
                if current_model not in new_models:
                    # Erstes verf√ºgbares Modell ausw√§hlen wenn aktuelles nicht verf√ºgbar
                    self.llm_var.set(new_models[0])
                    logger.info(f"üîÑ Modell gewechselt zu: {new_models[0]}")
                    
                logger.info(f"üîÑ Modelle erfolgreich aktualisiert: {len(new_models)} verf√ºgbar")
            else:
                # Bei Fehler auf Standard-Modelle zur√ºckgreifen
                fallback_models = ["gpt-3.5-turbo", "gpt-4", "claude-3"]
                self.llm_combo['values'] = fallback_models
                if not self.llm_var.get():
                    self.llm_var.set(fallback_models[0])
                logger.warning("‚ö†Ô∏è Fallback auf Standard-Modelle")
                
        except Exception as e:
            logger.error(f"‚ùå Fehler beim Aktualisieren der Modelle: {e}")

    def _on_dropdown_click(self, event):
        """Event-Handler f√ºr Dropdown-Klick - l√§dt Modelle automatisch neu"""
        try:
            # Nur beim ersten Klick aktualisieren oder wenn alt
            if not hasattr(self, '_last_model_refresh') or \
               (time.time() - self._last_model_refresh) > 30:  # 30 Sekunden Cache
                
                # Modelle im Hintergrund aktualisieren
                if self.window:
                    self.window.after_idle(self._refresh_models)
                self._last_model_refresh = time.time()
                
        except Exception as e:
            logger.error(f"‚ùå Fehler beim Dropdown-Click: {e}")
        except requests.exceptions.RequestException as e:
            logger.warning(f"‚ö†Ô∏è Verbindungsfehler beim Abrufen der LLM-Modelle: {e}")
            return None
        except Exception as e:
            logger.error(f"‚ùå Fehler beim Abrufen der LLM-Modelle: {e}")
            return None
    
    def _clear_chat(self):
        """L√∂scht den aktuellen Chat"""
        if messagebox.askyesno("Best√§tigung", "Chat wirklich l√∂schen?"):
            self.chat_messages = []
            self.chat_text.config(state=tk.NORMAL)
            self.chat_text.delete('1.0', tk.END)
            self.chat_text.insert(tk.END, "üóëÔ∏è Chat geleert\n\n", "system")
            self.chat_text.config(state=tk.DISABLED)
            
            # Alle Anh√§nge entfernen
            self._clear_all_attachments()
            
            logger.info("Chat geleert")
    
    def _copy_last_response(self):
        """Kopiert die letzte Antwort in die Zwischenablage"""
        if self.chat_messages:
            last_assistant_msg = None
            for msg in reversed(self.chat_messages):
                if msg.get('role') == 'assistant':
                    last_assistant_msg = msg.get('content')
                    break
            
            if last_assistant_msg:
                self.window.clipboard_clear()
                self.window.clipboard_append(last_assistant_msg)
                messagebox.showinfo("Erfolg", "Letzte Antwort in Zwischenablage kopiert")
            else:
                messagebox.showinfo("Info", "Keine Assistant-Antwort zum Kopieren vorhanden")
        else:
            messagebox.showinfo("Info", "Kein Chat vorhanden")
    
    def get_available_question_methods(self):
        """Ruft verf√ºgbare Frage-Modi vom API-Endpunkt ab"""
        logger.info("üîç Lade verf√ºgbare Frage-Modi vom API...")
        try:
            response = requests.get(f"{API_BASE_URL}/modes", timeout=10)
            logger.debug(f"API Response Status: {response.status_code}")
            if response.status_code == 200:
                data = response.json()
                modes = data.get('modes', {})
                available_modes = []
                
                logger.debug(f"Gefundene Modi: {list(modes.keys())}")
                
                for mode_key, mode_info in modes.items():
                    status = mode_info.get('status')
                    logger.debug(f"Modus {mode_key}: Status = {status}")
                    if status == 'implemented':
                        # Erstelle benutzerfreundliche Anzeige
                        display_name = mode_info.get('display_name', mode_key)
                        description = mode_info.get('description', '')
                        
                        # K√ºrze die Beschreibung f√ºr das Dropdown
                        if len(description) > 50:
                            description = description[:47] + "..."
                        
                        dropdown_text = f"{display_name}"
                        available_modes.append({
                            'key': mode_key.lower(),
                            'display': dropdown_text,
                            'endpoints': mode_info.get('endpoints', []),
                            'description': description
                        })
                
                if available_modes:
                    logger.info(f"‚úÖ {len(available_modes)} Frage-Modi verf√ºgbar: {[m['key'] for m in available_modes]}")
                    return available_modes
                else:
                    logger.warning("‚ö†Ô∏è Keine verf√ºgbaren Modi vom API erhalten")
                    return [
                        {'key': 'veritas', 'display': 'Standard RAG', 'endpoints': ['/ask'], 'description': 'Standard Retrieval-Augmented Generation'},
                        {'key': 'vpb', 'display': 'VPB Verwaltung', 'endpoints': ['/vpb/ask'], 'description': 'Verwaltungsprozess-Analyse'}
                    ]
            else:
                logger.error(f"‚ùå API-Fehler beim Abrufen der Modi: Status {response.status_code}")
                return [
                    {'key': 'veritas', 'display': 'Standard RAG', 'endpoints': ['/ask'], 'description': 'Standard Retrieval-Augmented Generation'},
                    {'key': 'vpb', 'display': 'VPB Verwaltung', 'endpoints': ['/vpb/ask'], 'description': 'Verwaltungsprozess-Analyse'}
                ]
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Verbindungsfehler beim Abrufen der Frage-Modi: {e}")
            return [
                {'key': 'veritas', 'display': 'Standard RAG', 'endpoints': ['/ask'], 'description': 'Standard Retrieval-Augmented Generation'},
                {'key': 'vpb', 'display': 'VPB Verwaltung', 'endpoints': ['/vpb/ask'], 'description': 'Verwaltungsprozess-Analyse'}
            ]
        except Exception as e:
            logger.error(f"‚ùå Unerwarteter Fehler beim Abrufen der Frage-Modi: {e}")
            return [
                {'key': 'veritas', 'display': 'Standard RAG', 'endpoints': ['/ask'], 'description': 'Standard Retrieval-Augmented Generation'},
                {'key': 'vpb', 'display': 'VPB Verwaltung', 'endpoints': ['/vpb/ask'], 'description': 'Verwaltungsprozess-Analyse'}
            ]
    
    def on_mode_change(self, event=None):
        """Behandelt Modus-√Ñnderung"""
        try:
            selected_display = self.mode_var.get()
            
            # Finde den entsprechenden Modus in den geladenen Daten
            if hasattr(self, 'question_methods_data') and selected_display in self.question_methods_data:
                selected_method = self.question_methods_data[selected_display]
                mode_key = selected_method['key']
                description = selected_method['description']
                
                # Speichere aktuellen Modus f√ºr API-Anfragen
                self.current_question_mode = selected_method
                
                # System-Nachricht hinzuf√ºgen falls Chat-Text verf√ºgbar
                if hasattr(self, 'chat_text') and self.chat_text:
                    self.chat_text.config(state=tk.NORMAL)
                    self.chat_text.insert(tk.END, f"üîÑ Frage-Modus gewechselt zu: {selected_display}\n", "system")
                    if description:
                        self.chat_text.insert(tk.END, f"‚ÑπÔ∏è {description}\n\n", "system")
                    else:
                        self.chat_text.insert(tk.END, "\n", "system")
                    self.chat_text.config(state=tk.DISABLED)
                    self.chat_text.see(tk.END)
                
                logger.info(f"Modus gewechselt zu: {mode_key} - {selected_display}")
            else:
                logger.warning(f"Modus {selected_display} nicht in question_methods_data gefunden")
        except Exception as e:
            logger.error(f"Fehler beim Modus-Wechsel: {e}")
    
    def _send_message(self):
        """Sendet eine Nachricht (gemeinsame Implementierung)"""
        if hasattr(self, 'input_text') and self.input_text:
            message = self.input_text.get('1.0', tk.END).strip()
            if message:
                self.input_text.delete('1.0', tk.END)
                self.send_chat_message(message)

# === OOP-ARCHITEKTUR: KONKRETE CHAT-WINDOW-IMPLEMENTIERUNGEN ===

class MainChatWindow(ChatWindowBase):
    """Hauptfenster - l√§uft im Main-Thread"""
    
    def __init__(self, thread_manager: ThreadManager, veritas_app=None):
        super().__init__("MainChat", thread_manager, parent=veritas_app)
        self.is_main_window = True
        self.veritas_app = veritas_app
        
        # Initialisiere aktuellen Frage-Modus
        self.current_question_mode = {'key': 'veritas', 'endpoints': ['/ask']}
        self.question_methods_data = {}
        
        self.create_gui()
        self.setup_bindings()
        
        # WICHTIG: Starte Message-Loop f√ºr Queue-basierte Kommunikation
        self.start_message_loop()
        
        logger.info("MainChatWindow erstellt")
    
    def create_gui(self):
        """Erstellt das Hauptfenster GUI mit shared Methoden"""
        self.window = tk.Tk()
        self.window.title("üí¨ Veritas Chat - Hauptfenster")
        self.window.geometry("900x700")
        self.window.minsize(700, 500)
        self.window.configure(bg='#f0f0f0')
        
        # Hauptframe
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Streaming-UI initialisieren (falls verf√ºgbar)
        if STREAMING_AVAILABLE:
            self.init_streaming_ui(main_frame)
        
        # Header mit Toolbar
        self._create_main_toolbar(main_frame)
        
        # Chat-Anzeige (shared)
        self._create_chat_display(main_frame, height=25)
        
        # UI-Module initialisieren (NACH Chat-Display-Erstellung)
        if UI_MODULES_AVAILABLE:
            self._init_ui_modules()
        
        # Eingabebereich mit Anh√§ngen (shared)
        self._create_input_area(main_frame, include_attachments=True)
        
        # Einstellungen (shared)
        self._create_settings_bar(main_frame, compact=False)
        
        # Status-Bar (shared)
        self._create_status_bar(main_frame, show_uds3=True)
    
    def _init_ui_modules(self):
        """Initialisiert die ausgelagerten UI-Module"""
        try:
            # Markdown-Renderer
            self.markdown_renderer = MarkdownRenderer(self.chat_text)
            
            # Source-Link-Handler
            self.source_link_handler = SourceLinkHandler(self.window, self.status_var)
            
            # Chat-Display-Formatter (‚ú® v3.19.0: mit suggestion_click_callback)
            self.chat_formatter = ChatDisplayFormatter(
                self.chat_text,
                self.window,
                markdown_renderer=self.markdown_renderer,
                source_link_handler=self.source_link_handler,
                suggestion_click_callback=self._on_suggestion_clicked  # ‚ú® NEW
            )
            
            # Dialog-Manager
            self.dialog_manager = DialogManager(
                self.window,
                chat_messages=self.chat_messages,
                status_var=self.status_var,
                update_chat_callback=lambda: self.chat_formatter.update_chat_display(self.chat_messages)
            )
            
            # Link-Callback setzen
            self.markdown_renderer.set_link_callback(self.source_link_handler.open_source_link)
            
            # Tags konfigurieren
            setup_markdown_tags(self.chat_text)
            setup_chat_tags(self.chat_text)
            
            logger.info("‚úÖ UI-Module initialisiert (Markdown, SourceLinks, ChatFormatter, DialogManager)")
            
        except Exception as e:
            logger.error(f"‚ùå Fehler beim Initialisieren der UI-Module: {e}")
            # Fallback auf alte Methoden
            self.markdown_renderer = None
            self.source_link_handler = None
            self.chat_formatter = None
            self.dialog_manager = None
    
    def _create_main_toolbar(self, parent):
        """Erstellt die Hauptfenster-spezifische Toolbar"""
        header_frame = ttk.Frame(parent)
        header_frame.pack(fill=tk.X, pady=(0, 5))
        
        # Hamburger-Men√º (linksb√ºndig)
        self.hamburger_btn = ttk.Button(
            header_frame,
            text="‚ò∞",
            command=self._show_menu,
            width=3
        )
        self.hamburger_btn.pack(side=tk.LEFT)
        Tooltip(self.hamburger_btn, "Men√º √∂ffnen")
        
        # Toolbar-Buttons (zentral)
        toolbar_frame = ttk.Frame(header_frame)
        toolbar_frame.pack(side=tk.LEFT, padx=(10, 0))
        
        clear_btn = ttk.Button(toolbar_frame, text="üóëÔ∏è Chat l√∂schen", 
                  command=self._clear_chat, width=13)
        clear_btn.pack(side=tk.LEFT, padx=(0, 5))
        Tooltip(clear_btn, "Chat l√∂schen (Strg+K)")
        
        copy_btn = ttk.Button(toolbar_frame, text="üìã Kopieren", 
                  command=self._copy_last_response, width=13)
        copy_btn.pack(side=tk.LEFT, padx=(0, 5))
        Tooltip(copy_btn, "Letzte Antwort kopieren")
        
        repeat_btn = ttk.Button(toolbar_frame, text="üîÑ Wiederholen", 
                  command=self._repeat_last_question, width=13)
        repeat_btn.pack(side=tk.LEFT)
        Tooltip(repeat_btn, "Letzte Frage wiederholen")
        
        # VERITAS Info Button (rechtsb√ºndig) - ohne Rahmen, gro√üe Schrift
        veritas_btn = tk.Label(
            header_frame,
            text="VERITAS",
            font=('Segoe UI', 16, 'bold'),
            foreground='#0066CC',
            padx=10,
            pady=5
        )
        veritas_btn.pack(side=tk.RIGHT, padx=(5, 0))
        veritas_btn.config(cursor='hand2')  # Cursor separat setzen
        veritas_btn.bind('<Button-1>', lambda e: self._show_readme())
        Tooltip(veritas_btn, "Hilfe anzeigen (F1)")
        
        # Hover-Effekt f√ºr VERITAS Button
        def on_enter(e):
            veritas_btn.config(foreground='#004499')
        def on_leave(e):
            veritas_btn.config(foreground='#0066CC')
        
        veritas_btn.bind('<Enter>', on_enter)
        veritas_btn.bind('<Leave>', on_leave)
        
        # Neuer Chat Button (rechtsb√ºndig)
        new_chat_btn = ttk.Button(
            header_frame,
            text="‚ûï Neuer Chat",
            command=self._create_child_window,
            width=12
        )
        new_chat_btn.pack(side=tk.RIGHT, padx=(5, 0))
        Tooltip(new_chat_btn, "Neuer Chat (Strg+N)")
    
    def setup_bindings(self):
        """Richtet Event-Bindings ein"""
        # Input-Field Bindings
        self.input_text.bind('<Control-Return>', lambda e: self._send_message())
        self.input_text.bind('<Return>', self._on_return_key)
        
        # ‚ú® Feature #11: Keyboard Shortcuts
        # Globale Shortcuts f√ºr Hauptfenster
        self.window.bind('<Control-n>', lambda e: self._create_child_window())  # Neuer Chat
        self.window.bind('<Control-s>', lambda e: self._save_chat())  # Chat speichern
        self.window.bind('<Control-o>', lambda e: self._load_chat())  # Chat laden
        self.window.bind('<Control-k>', lambda e: self._clear_chat())  # Chat l√∂schen
        self.window.bind('<Control-slash>', lambda e: self._show_shortcuts_help())  # Shortcuts anzeigen
        self.window.bind('<Escape>', lambda e: self.input_text.focus_set())  # Focus zu Input
        self.window.bind('<F1>', lambda e: self._show_readme())  # Hilfe
        
        # Window Close
        self.window.protocol("WM_DELETE_WINDOW", self._on_main_window_closing)
    
    def _on_return_key(self, event):
        """Behandelt Return-Key"""
        if event.state & 0x1:  # Shift-Taste gedr√ºckt
            return None
        else:
            self._send_message()
            return "break"
    
    def _send_message(self):
        """Sendet eine Nachricht"""
        message = self.input_text.get('1.0', tk.END).strip()
        if not message:
            return
        
        self.input_text.delete('1.0', tk.END)
        self.send_chat_message(message)
    
    def _create_child_window(self):
        """Erstellt ein neues Child-Chat-Fenster"""
        if self.veritas_app:
            self.veritas_app.create_child_chat_window()
    
    def _show_menu(self):
        """Zeigt das Hamburger-Men√º mit letzten Chats"""
        menu = tk.Menu(self.window, tearoff=0)
        menu.add_command(label="‚ûï Neuer Chat", command=self._create_child_window)
        menu.add_separator()
        menu.add_command(label="üíæ Chat speichern", command=self._save_chat)
        menu.add_command(label="üìÇ Chat laden", command=self._load_chat)
        
        # Letzte Chats anzeigen
        recent_chats = self._get_recent_chats()
        if recent_chats:
            menu.add_separator()
            menu.add_command(label="üìú Letzte Chats:", state="disabled")  # Header
            
            # Zeige maximal 5 Chats direkt im Men√º
            for i, chat_info in enumerate(recent_chats[:5]):
                chat_name = chat_info['name']
                chat_path = chat_info['path']
                # K√ºrze den Namen wenn n√∂tig (max 30 Zeichen)
                display_name = chat_name[:27] + "..." if len(chat_name) > 30 else chat_name
                menu.add_command(
                    label=f"  {display_name}",
                    command=lambda path=chat_path: self._load_recent_chat(path)
                )
            
            # Wenn mehr als 5 Chats vorhanden, zeige "Alle anzeigen" Option
            if len(recent_chats) > 5:
                menu.add_command(label="  üìã Alle Chats anzeigen...", command=self._show_all_chats_dialog)
        
        menu.add_separator()
        menu.add_command(label="‚öôÔ∏è Einstellungen", command=self._show_settings)
        menu.add_command(label="‚å®Ô∏è Keyboard Shortcuts", command=self._show_shortcuts_help)
        menu.add_command(label="‚ÑπÔ∏è Info", command=self._show_info)
        
        try:
            x = self.hamburger_btn.winfo_rootx()
            y = self.hamburger_btn.winfo_rooty() + self.hamburger_btn.winfo_height()
            menu.tk_popup(x, y)
        except:
            menu.tk_popup(100, 100)
    
    def _save_chat(self):
        """Speichert den aktuellen Chat (delegiert an DialogManager)"""
        if hasattr(self, 'dialog_manager') and self.dialog_manager:
            self.dialog_manager.save_chat(self.chat_messages)
        else:
            # Fallback: Alte Implementierung
            self._save_chat_legacy()
    
    def _load_chat(self):
        """L√§dt einen gespeicherten Chat (delegiert an DialogManager)"""
        if hasattr(self, 'dialog_manager') and self.dialog_manager:
            loaded = self.dialog_manager.load_chat()
            if loaded:
                self.chat_messages = loaded
                self.update_chat_display()
        else:
            # Fallback: Alte Implementierung
            self._load_chat_legacy()
    
    def _get_recent_chats(self):
        """Gibt Liste der letzten Chats zur√ºck"""
        try:
            # Nutze Chat-Persistence-Service (v3.20.0)
            if hasattr(self, 'chat_persistence') and self.chat_persistence:
                sessions = self.chat_persistence.list_all_sessions()
                # Sortiere nach updated_at (neueste zuerst)
                sessions.sort(key=lambda s: s.get('updated_at', ''), reverse=True)
                # Nimm die letzten 10
                return sessions[:10]
            elif hasattr(self, 'dialog_manager') and self.dialog_manager:
                # Fallback: Alte DialogManager-Methode (falls vorhanden)
                if hasattr(self.dialog_manager, 'get_recent_chats'):
                    return self.dialog_manager.get_recent_chats()
                else:
                    return []
            else:
                # Fallback: Leere Liste
                return []
        except Exception as e:
            logger.warning(f"Fehler beim Laden der letzten Chats: {e}")
            return []
    
    def _load_recent_chat(self, chat_path):
        """L√§dt einen spezifischen Chat aus dem Pfad"""
        try:
            if hasattr(self, 'dialog_manager') and self.dialog_manager:
                loaded = self.dialog_manager.load_chat_from_path(chat_path)
                if loaded:
                    self.chat_messages = loaded
                    self.update_chat_display()
            else:
                # Fallback: Datei direkt laden
                import json
                with open(chat_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.chat_messages = data.get('messages', [])
                    self.update_chat_display()
        except Exception as e:
            logger.error(f"Fehler beim Laden des Chats: {e}")
            messagebox.showerror("Fehler", f"Konnte Chat nicht laden:\n{e}")
    
    def _show_all_chats_dialog(self):
        """Zeigt Dialog mit allen verf√ºgbaren Chats (delegiert an DialogManager)"""
        if hasattr(self, 'dialog_manager') and self.dialog_manager:
            self.dialog_manager.show_all_chats_dialog()
        else:
            self._show_all_chats_dialog_legacy()
    
    def _show_settings(self):
        """Zeigt Einstellungen-Dialog (delegiert an DialogManager)"""
        if hasattr(self, 'dialog_manager') and self.dialog_manager:
            self.dialog_manager.show_settings()
        else:
            messagebox.showinfo("Einstellungen", "Einstellungen werden in einem zuk√ºnftigen Update verf√ºgbar sein")
    
    def _show_shortcuts_help(self):
        """Zeigt Keyboard-Shortcuts-Hilfe (Feature #11)"""
        shortcuts_text = """‚å®Ô∏è Keyboard Shortcuts

Chat-Steuerung:
  Strg+N      ‚ûï Neuer Chat (Child-Fenster)
  Strg+S      üíæ Chat speichern
  Strg+O      üìÇ Chat laden
  Strg+K      üóëÔ∏è Chat l√∂schen

Navigation:
  Esc         üéØ Focus zu Eingabefeld
  F1          ‚ùì Hilfe (README)
  Strg+/      ‚å®Ô∏è Diese Shortcuts anzeigen

Nachrichten senden:
  Strg+Enter  üì§ Nachricht senden
  Enter       üì§ Nachricht senden
  Shift+Enter ‚èé Neue Zeile (ohne Senden)
"""
        messagebox.showinfo("Keyboard Shortcuts", shortcuts_text)
    
    def _show_info(self):
        """Zeigt Info-Dialog (delegiert an DialogManager)"""
        if hasattr(self, 'dialog_manager') and self.dialog_manager:
            self.dialog_manager.show_info(__version__)
        else:
            info_text = f"""Veritas Chat v{__version__}
        
Moderne Chat-Anwendung mit:
‚Ä¢ Multi-Window-Unterst√ºtzung
‚Ä¢ RAG-Integration
‚Ä¢ HTTP/HTTPS Backend-API
‚Ä¢ Feedback-System

¬© 2025 Veritas Team"""
        messagebox.showinfo("Info", info_text)
    
    def _show_readme(self):
        """Zeigt die README.md Datei (delegiert an DialogManager)"""
        if hasattr(self, 'dialog_manager') and self.dialog_manager:
            self.dialog_manager.show_readme()
        else:
            self._show_readme_legacy()
    
    def _on_main_window_closing(self):
        """Behandelt das Schlie√üen des Hauptfensters thread-sicher"""
        try:
            if self.veritas_app:
                self.veritas_app.handle_main_window_closing()
            else:
                self._safe_destroy()
        except Exception as e:
            logger.error(f"Fehler beim Schlie√üen des Hauptfensters: {e}")
    
    def update_chat_display(self):
        """Aktualisiert Chat-Anzeige (delegiert an ChatDisplayFormatter)"""
        if hasattr(self, 'chat_formatter') and self.chat_formatter:
            self.chat_formatter.update_chat_display(self.chat_messages)
        else:
            logger.warning("‚ö†Ô∏è ChatFormatter nicht verf√ºgbar - UI-Module fehlen!")
    
    def _safe_update_chat_display(self):
        """Sichere Chat-Display-Aktualisierung mit Widget-Existenz-Pr√ºfung"""
        try:
            self.update_chat_display()
        except tk.TclError:
            logger.debug(f"Chat-Display-Update f√ºr {self.window_id} - Widget bereits zerst√∂rt")
        except Exception as e:
            logger.debug(f"Fehler bei Chat-Display-Update: {e}")

class ChildChatWindow(ChatWindowBase):
    """Child-Fenster - l√§uft in separatem Thread"""
    
    def __init__(self, window_id: str, thread_manager: ThreadManager, veritas_app=None):
        super().__init__(window_id, thread_manager, parent=veritas_app)
        self.veritas_app = veritas_app
        
        self.create_gui()
        self.setup_bindings()
        self.start_message_loop()
        
        logger.info(f"ChildChatWindow {window_id} erstellt")
    
    def create_gui(self):
        """Erstellt das Child-Fenster GUI mit shared Methoden"""
        self.window = tk.Toplevel()
        self.window.title(f"üí¨ Veritas Chat - {self.window_id}")
        self.window.geometry("800x600")
        self.window.minsize(600, 400)
        self.window.configure(bg='#f0f0f0')
        
        # Hauptframe
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Header mit kompakter Toolbar
        self._create_child_toolbar(main_frame)
        
        # Chat-Anzeige (shared)
        self._create_chat_display(main_frame, height=20)
        
        # Eingabebereich ohne Anh√§nge (shared)
        self._create_input_area(main_frame, include_attachments=False)
        
        # Kompakte Einstellungen (shared)
        self._create_settings_bar(main_frame, compact=True)
        
        # Status-Bar ohne UDS3 (shared)
        self._create_status_bar(main_frame, show_uds3=False)
    
    def _create_child_toolbar(self, parent):
        """Erstellt die Child-Fenster-spezifische Toolbar"""
        header_frame = ttk.Frame(parent)
        header_frame.pack(fill=tk.X, pady=(0, 5))
        
        # Kompakte Toolbar (links)
        toolbar_frame = ttk.Frame(header_frame)
        toolbar_frame.pack(side=tk.LEFT)
        
        ttk.Button(toolbar_frame, text="üóëÔ∏è", 
                  command=self._clear_chat, width=3).pack(side=tk.LEFT)
        ttk.Button(toolbar_frame, text="üìé", 
                  command=self._upload_file, width=3).pack(side=tk.LEFT, padx=(2, 0))
        ttk.Button(toolbar_frame, text="üìã", 
                  command=self._copy_last_response, width=3).pack(side=tk.LEFT, padx=(2, 0))
        
        # Close Button (rechts)
        ttk.Button(
            header_frame,
            text="‚ùå Schlie√üen",
            command=self._on_window_closing,
            width=12
        ).pack(side=tk.RIGHT)
    
    def setup_bindings(self):
        """Richtet Event-Bindings ein"""
        self.input_text.bind('<Control-Return>', lambda e: self._send_message())
        self.input_text.bind('<Return>', self._on_return_key)
        self.window.protocol("WM_DELETE_WINDOW", self._on_window_closing)
    
    def _on_return_key(self, event):
        """Behandelt Return-Key"""
        if event.state & 0x1:  # Shift-Taste gedr√ºckt
            return None
        else:
            self._send_message()
            return "break"
    
    def _send_message(self):
        """Sendet eine Nachricht"""
        message = self.input_text.get('1.0', tk.END).strip()
        if not message:
            return
        
        self.input_text.delete('1.0', tk.END)
        self.send_chat_message(message)
    
    def _on_window_closing(self):
        """Behandelt das Schlie√üen des Child-Fensters thread-sicher"""
        try:
            self._safe_destroy()
            if self.veritas_app:
                self.veritas_app.remove_child_window(self.window_id)
        except Exception as e:
            logger.error(f"Fehler beim Schlie√üen des Child-Fensters {self.window_id}: {e}")
    
    def update_chat_display(self):
        """Aktualisiert Chat-Anzeige im Child-Fenster"""
        if not self.window or not hasattr(self.window, 'winfo_exists') or not self.window.winfo_exists():
            return
            
        self.chat_text.config(state='normal')
        self.chat_text.delete('1.0', tk.END)
        
        for msg in self.chat_messages:
            role = msg.get('role', 'unknown')
            content = msg.get('content', '')
            timestamp = msg.get('timestamp', '')
            tag = msg.get('tag', role)
            
            if role == 'system':
                self.chat_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
                self.chat_text.insert(tk.END, f"{content}\n\n", "system")
            elif role == 'user':
                self.chat_text.insert(tk.END, f"[{timestamp}] Sie:\n", "user")
                self.chat_text.insert(tk.END, f"{content}\n\n", "user")
            elif role == 'assistant':
                self.chat_text.insert(tk.END, f"[{timestamp}] Assistent:\n", tag)
                self.chat_text.insert(tk.END, f"{content}\n\n", tag)
            elif role == 'error':
                self.chat_text.insert(tk.END, f"[{timestamp}] Fehler:\n", "system")
                self.chat_text.insert(tk.END, f"{content}\n\n", "system")
        
        self.chat_text.config(state='disabled')
        self.chat_text.see(tk.END)
    
    def _safe_update_chat_display(self):
        """Sichere Chat-Display-Aktualisierung mit Widget-Existenz-Pr√ºfung"""
        try:
            self.update_chat_display()
        except tk.TclError:
            logger.debug(f"Chat-Display-Update f√ºr {self.window_id} - Widget bereits zerst√∂rt")
        except Exception as e:
            logger.debug(f"Fehler bei Chat-Display-Update: {e}")

# === OOP-ARCHITEKTUR: HAUPTANWENDUNG MIT MULTI-WINDOW-MANAGEMENT ===

class VeritasApp:
    """
    Hauptanwendung mit OOP-basiertem Multi-Window-Management
    Implementiert das moderne Design mit korrekter Thread-Architektur
    """
    
    def __init__(self):
        # Globale App-Instanz setzen
        global _veritas_app_instance
        _veritas_app_instance = self
        
        # Thread-Manager aus Core Engine oder Fallback verwenden
        self.thread_manager = get_thread_manager()
        
        # Core Engine initialisieren falls verf√ºgbar
        if CORE_AVAILABLE:
            self.veritas_core = get_veritas_core()
            logger.info("‚úÖ VERITAS Core Engine eingebunden")
        else:
            self.veritas_core = None
            logger.warning("‚ö†Ô∏è VERITAS Core Engine nicht verf√ºgbar")
        
        # Backend Capabilities
        self.capabilities: Dict[str, Any] = {}
        self._load_backend_capabilities()
        
        # Window-Management
        self.main_window: Optional[MainChatWindow] = None
        self.child_windows: Dict[str, ChildChatWindow] = {}
        
        # Shutdown-Flag um Doppelausf√ºhrung zu verhindern
        self._shutdown_initiated = False
        self._window_counter = 0
        
        logger.info(f"VeritasApp v{__version__} initialisiert")
    
    def _load_backend_capabilities(self):
        """
        L√§dt Backend-Capabilities vom /capabilities Endpoint
        Erm√∂glicht dynamische Feature-Anpassung im Frontend
        """
        try:
            logger.info("üîç Lade Backend Capabilities...")
            response = requests.get(f"{API_BASE_URL}/capabilities", timeout=10)
            
            if response.status_code == 200:
                self.capabilities = response.json()
                
                # Log wichtige Informationen
                system_info = self.capabilities.get('system', {})
                features = self.capabilities.get('features', {})
                modes = self.capabilities.get('modes', {})
                recommendations = self.capabilities.get('recommendations', [])
                
                logger.info(f"‚úÖ Backend Capabilities geladen:")
                logger.info(f"   Version: {system_info.get('version', 'unknown')}")
                logger.info(f"   Environment: {system_info.get('environment', 'unknown')}")
                
                # Ollama Status
                ollama = features.get('ollama', {})
                if ollama.get('available'):
                    logger.info(f"   Ollama: {ollama.get('model_count', 0)} Modelle verf√ºgbar")
                    logger.info(f"   Default Model: {ollama.get('default_model', 'unknown')}")
                else:
                    logger.warning(f"   ‚ö†Ô∏è Ollama nicht verf√ºgbar")
                
                # Pipeline Status
                pipeline = features.get('intelligent_pipeline', {})
                if pipeline.get('available'):
                    logger.info(f"   Pipeline: {len(pipeline.get('available_agents', []))} Agents")
                else:
                    logger.warning(f"   ‚ö†Ô∏è Intelligent Pipeline nicht verf√ºgbar")
                
                # UDS3 Status
                uds3 = features.get('uds3', {})
                if uds3.get('available'):
                    logger.info(f"   UDS3: Multi-DB mit {len(uds3.get('databases', []))} DBs")
                else:
                    logger.info(f"   UDS3: Nicht verf√ºgbar (optional)")
                
                # Modi Status
                optimal_modes = [k for k, v in modes.items() if v.get('optimal', False)]
                logger.info(f"   Optimale Modi: {', '.join(optimal_modes)}")
                
                # Recommendations
                for rec in recommendations:
                    rec_type = rec.get('type', 'info')
                    message = rec.get('message', '')
                    if rec_type == 'warning':
                        logger.warning(f"   ‚ö†Ô∏è {message}")
                    elif rec_type == 'error':
                        logger.error(f"   ‚ùå {message}")
                    elif rec_type == 'success':
                        logger.info(f"   ‚úÖ {message}")
                    else:
                        logger.info(f"   ‚ÑπÔ∏è {message}")
                
                return True
                
            else:
                logger.error(f"‚ùå Capabilities-Fehler: Status {response.status_code}")
                self.capabilities = self._get_fallback_capabilities()
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Verbindungsfehler bei Capabilities: {e}")
            self.capabilities = self._get_fallback_capabilities()
            return False
        except Exception as e:
            logger.error(f"‚ùå Unerwarteter Fehler bei Capabilities: {e}")
            self.capabilities = self._get_fallback_capabilities()
            return False
    
    def _get_fallback_capabilities(self) -> Dict[str, Any]:
        """Fallback Capabilities wenn Backend nicht erreichbar"""
        return {
            "system": {
                "version": "unknown",
                "environment": "offline",
                "timestamp": datetime.now().isoformat()
            },
            "features": {
                "ollama": {"available": False, "models": []},
                "intelligent_pipeline": {"available": False},
                "uds3": {"available": False},
                "streaming": {"available": False}
            },
            "modes": {
                "veritas": {"available": False, "optimal": False},
                "chat": {"available": False, "optimal": False}
            },
            "recommendations": [
                {
                    "type": "error",
                    "message": "Backend nicht erreichbar",
                    "action": "Starten Sie das Backend mit: python backend/api/veritas_api_backend.py"
                }
            ]
        }
    
    def is_feature_available(self, feature_path: str) -> bool:
        """
        Pr√ºft ob ein Feature verf√ºgbar ist
        
        Args:
            feature_path: Pfad im Capabilities-Dict, z.B. 'features.ollama.available'
        
        Returns:
            bool: True wenn Feature verf√ºgbar
        """
        parts = feature_path.split('.')
        current = self.capabilities
        
        for part in parts:
            if isinstance(current, dict) and part in current:
                current = current[part]
            else:
                return False
        
        return bool(current)
    
    def get_capability_value(self, path: str, default: Any = None) -> Any:
        """
        Holt einen Wert aus den Capabilities
        
        Args:
            path: Pfad im Capabilities-Dict, z.B. 'features.ollama.models'
            default: R√ºckgabewert wenn Pfad nicht existiert
        
        Returns:
            Der Wert am Pfad oder default
        """
        parts = path.split('.')
        current = self.capabilities
        
        for part in parts:
            if isinstance(current, dict) and part in current:
                current = current[part]
            else:
                return default
        
        return current
    
    def get_available_llm_models(self):
        """Ruft verf√ºgbare LLM-Modelle aus den Capabilities ab"""
        # Pr√ºfe zuerst Capabilities
        if self.capabilities:
            models = self.get_capability_value('features.ollama.models', [])
            if models:
                logger.info(f"‚úÖ {len(models)} LLM-Modelle aus Capabilities geladen")
                return models
        
        # Fallback: API-Call (f√ºr R√ºckw√§rtskompatibilit√§t)
        try:
            response = requests.get(f"{API_BASE_URL}/get_models", timeout=10)
            if response.status_code == 200:
                data = response.json()
                models = data.get('models', [])
                if models:
                    # Extrahiere nur die Modellnamen
                    model_names = [model.get('name', 'unknown') for model in models]
                    logger.info(f"‚úÖ {len(model_names)} LLM-Modelle vom API abgerufen")
                    return model_names
                else:
                    logger.warning("‚ö†Ô∏è Keine LLM-Modelle vom API erhalten")
                    return ["llama3:latest", "mistral:latest", "codellama:latest"]
            else:
                logger.error(f"‚ùå API-Fehler beim Abrufen der Modelle: Status {response.status_code}")
                return ["llama3:latest", "mistral:latest", "codellama:latest"]
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Verbindungsfehler beim Abrufen der LLM-Modelle: {e}")
            return ["llama3:latest", "mistral:latest", "codellama:latest"]
        except Exception as e:
            logger.error(f"‚ùå Unerwarteter Fehler beim Abrufen der LLM-Modelle: {e}")
            return ["llama3:latest", "mistral:latest", "codellama:latest"]

    def get_available_question_methods(self):
        """Ruft verf√ºgbare Frage-Modi aus den Capabilities ab"""
        logger.info("üîç Lade verf√ºgbare Frage-Modi...")
        
        # Pr√ºfe zuerst Capabilities
        if self.capabilities:
            modes = self.get_capability_value('modes', {})
            endpoints_info = self.get_capability_value('endpoints', {})
            
            if modes:
                available_modes = []
                
                # Erstelle Modi-Liste aus Capabilities
                for mode_key, mode_info in modes.items():
                    if mode_info.get('available', False):
                        # Bestimme ob Modus optimal ist
                        optimal = mode_info.get('optimal', False)
                        status_text = "‚úÖ Optimal" if optimal else "‚ö†Ô∏è Eingeschr√§nkt"
                        
                        # Finde zugeh√∂rige Endpoints
                        mode_endpoints = []
                        for endpoint_key, endpoint_info in endpoints_info.items():
                            if mode_key in endpoint_key.lower() or endpoint_key.lower() in mode_key.lower():
                                if endpoint_info.get('available', False):
                                    mode_endpoints.append(endpoint_info.get('path', ''))
                        
                        # Fallback Endpoint
                        if not mode_endpoints:
                            mode_endpoints = ['/v2/query']
                        
                        # Beschreibung erstellen
                        requires = mode_info.get('requires', [])
                        description = f"{status_text} - Ben√∂tigt: {', '.join(requires)}"
                        
                        display_name = mode_key.upper()
                        
                        available_modes.append({
                            'key': mode_key.lower(),
                            'display': display_name,
                            'endpoints': mode_endpoints,
                            'description': description,
                            'optimal': optimal
                        })
                
                if available_modes:
                    # Sortiere: Optimale Modi zuerst
                    available_modes.sort(key=lambda m: (not m.get('optimal', False), m['key']))
                    logger.info(f"‚úÖ {len(available_modes)} Frage-Modi aus Capabilities: {[m['key'] for m in available_modes]}")
                    return available_modes
        
        # Fallback: API-Call (f√ºr R√ºckw√§rtskompatibilit√§t)
        try:
            response = requests.get(f"{API_BASE_URL}/modes", timeout=10)
            if response.status_code == 200:
                data = response.json()
                modes = data.get('modes', {})
                available_modes = []
                
                for mode_key, mode_info in modes.items():
                    status = mode_info.get('status')
                    if status == 'implemented':
                        display_name = mode_info.get('display_name', mode_key)
                        description = mode_info.get('description', '')
                        
                        if len(description) > 50:
                            description = description[:47] + "..."
                        
                        available_modes.append({
                            'key': mode_key.lower(),
                            'display': display_name,
                            'endpoints': mode_info.get('endpoints', []),
                            'description': description
                        })
                
                if available_modes:
                    logger.info(f"‚úÖ {len(available_modes)} Frage-Modi vom API")
                    return available_modes
        except Exception as e:
            logger.debug(f"Fallback API-Call fehlgeschlagen: {e}")
        
        # Final Fallback
        logger.warning("‚ö†Ô∏è Verwende Standard-Modi (Fallback)")
        return [
            {'key': 'veritas', 'display': 'VERITAS', 'endpoints': ['/v2/query'], 'description': 'Standard RAG', 'optimal': True},
            {'key': 'chat', 'display': 'CHAT', 'endpoints': ['/v2/query'], 'description': 'Chat-Modus', 'optimal': True}
        ]
    
    def create_main_window(self):
        """Erstellt das Hauptfenster"""
        if self.main_window:
            logger.warning("Hauptfenster bereits vorhanden")
            return
        
        self.main_window = MainChatWindow(self.thread_manager, self)
        logger.info("Hauptfenster erstellt")
    
    def create_child_chat_window(self):
        """Erstellt ein neues Child-Chat-Fenster"""
        self._window_counter += 1
        window_id = f"Chat-{self._window_counter:03d}"
        
        child_window = ChildChatWindow(window_id, self.thread_manager, self)
        self.child_windows[window_id] = child_window
        
        logger.info(f"Child-Fenster {window_id} erstellt - Gesamt: {len(self.child_windows)}")
    
    def handle_main_window_closing(self):
        """
        Behandelt das Schlie√üen des Hauptfensters
        - Wenn Child-Fenster vorhanden: √úbernimmt Inhalt des ersten Child-Fensters automatisch
        - Wenn keine Child-Fenster: Beendet die Anwendung
        """
        if self.child_windows:
            # W√§hle das erste Child-Fenster f√ºr automatische √úbernahme
            child_id, child_window = next(iter(self.child_windows.items()))
            
            # Inhalt automatisch √ºbernehmen (technisch bedingt)
            if child_window.chat_messages and self.main_window:
                child_window.transfer_to_window(self.main_window)
                logger.info(f"Chat-Inhalt von {child_id} automatisch ins Hauptfenster √ºbernommen")
                
                # Status aktualisieren
                self.main_window.status_var.set(f"Chat von {child_id} √ºbernommen - {len(self.child_windows)-1} weitere Fenster")
            
            # Child-Window schlie√üen
            self._close_child_window(child_id)
        
        else:
            # Keine Child-Fenster - Anwendung beenden
            self._shutdown_application()
    
    def handle_child_window_closing(self, child_window: ChildChatWindow):
        """Behandelt das Schlie√üen eines Child-Fensters"""
        window_id = child_window.window_id
        
        if child_window.chat_messages:
            # Frage, ob Inhalt ins Hauptfenster √ºbernommen werden soll
            result = messagebox.askyesnocancel(
                "Chat √ºbernehmen?",
                f"M√∂chten Sie den Chat '{window_id}' ins Hauptfenster √ºbernehmen?"
            )
            
            if result is True:  # Ja - √úbernehmen
                if self.main_window:
                    child_window.transfer_to_window(self.main_window)
                    self.main_window.status_var.set(f"Chat von {window_id} √ºbernommen")
                    logger.info(f"Chat-Inhalt von {window_id} ins Hauptfenster √ºbernommen")
            elif result is None:  # Abbrechen
                return  # Schlie√üen abbrechen
            # Bei "Nein" wird ohne √úbernahme geschlossen
        
        # Child-Window schlie√üen
        self._close_child_window(window_id)
    
    def _close_child_window(self, window_id: str):
        """Schlie√üt ein Child-Fenster sauber"""
        if window_id in self.child_windows:
            child_window = self.child_windows[window_id]
            child_window.close_window()
            del self.child_windows[window_id]
            
            logger.info(f"Child-Fenster {window_id} geschlossen - Verbleibend: {len(self.child_windows)}")
            
            # Status im Hauptfenster aktualisieren
            if self.main_window:
                self.main_window.status_var.set(f"Bereit - {len(self.child_windows)} Child-Fenster")
    
    def _shutdown_application(self):
        """Beendet die Anwendung sauber"""
        if self._shutdown_initiated:
            logger.debug("Shutdown bereits initiiert, √ºberspringe...")
            return
            
        self._shutdown_initiated = True
        logger.info("Beende Anwendung...")
        
        # Alle Child-Fenster schlie√üen
        for window_id in list(self.child_windows.keys()):
            self._close_child_window(window_id)
        
        # Thread-Manager herunterfahren
        self.thread_manager.shutdown_all()
        
        # Hauptfenster schlie√üen
        if self.main_window and self.main_window.window:
            try:
                if self.main_window.window.winfo_exists():
                    self.main_window.window.destroy()
            except tk.TclError:
                # Widget bereits zerst√∂rt
                pass
        
        logger.info("Anwendung beendet")
    
    def _load_last_conversation(self):
        """L√§dt automatisch die letzte Conversation beim Start"""
        try:
            recent_chats = self.main_window._get_recent_chats()
            if recent_chats:
                latest_chat = recent_chats[0]  # Neueste Chat (nach mtime sortiert)
                chat_path = latest_chat['path']
                chat_name = latest_chat['name']
                
                # Pr√ºfe ob die Datei nicht √§lter als 7 Tage ist
                import time
                age_days = (time.time() - latest_chat['mtime']) / (24 * 60 * 60)
                
                if age_days <= 7:  # Nur Chats der letzten Woche automatisch laden
                    try:
                        with open(chat_path, 'r', encoding='utf-8') as f:
                            chat_messages = json.load(f)
                        
                        # Validiere Chat-Format
                        if isinstance(chat_messages, list) and len(chat_messages) > 0:
                            self.main_window.chat_messages = chat_messages
                            
                            # Status-Update
                            import os
                            filename = os.path.basename(chat_path)
                            logger.info(f"Letzte Conversation automatisch geladen: {chat_name} ({filename})")
                            
                            # Session-ID aus Chat extrahieren falls vorhanden
                            for msg in chat_messages:
                                if isinstance(msg, dict) and msg.get('session_id'):
                                    self.main_window.session_id = msg['session_id']
                                    break
                            
                            return True
                            
                    except Exception as e:
                        logger.warning(f"Fehler beim Laden der letzten Conversation: {e}")
                else:
                    logger.info(f"Letzte Conversation ist {age_days:.1f} Tage alt - √ºberspringe automatisches Laden")
            
        except Exception as e:
            logger.debug(f"Keine automatische Conversation-Wiederherstellung m√∂glich: {e}")
        
        return False
    
    def run(self):
        """Startet die Anwendung"""
        try:
            # Hauptfenster erstellen
            self.create_main_window()
            
            # Versuche letzte Conversation zu laden
            self._load_last_conversation()
            
            # Willkommensnachricht (nur wenn keine Conversation geladen wurde)
            if not self.main_window.chat_messages:
                welcome_message = {
                    'role': 'system',
                    'content': f'Willkommen bei Veritas v{__version__}! üöÄ\n'
                              f'Backend-API: {API_BASE_URL}\n'
                              f'Dr√ºcken Sie "‚ûï Neuer Chat" um weitere Fenster zu √∂ffnen.',
                    'timestamp': datetime.now().isoformat()
                }
                self.main_window.chat_messages.append(welcome_message)
            
            self.main_window.update_chat_display()
            
            # Main-Loop starten
            logger.info("Starte Tkinter Main-Loop...")
            self.main_window.window.mainloop()
            
        except Exception as e:
            logger.error(f"Fehler in der Hauptschleife: {e}")
            import traceback
            traceback.print_exc()  # Vollst√§ndigen Traceback ausgeben
            messagebox.showerror("Kritischer Fehler", f"Anwendung muss beendet werden:\n{e}")
        finally:
            self._shutdown_application()

# Globaler App-Referenz f√ºr Fenster-Management
_veritas_app_instance = None

def get_veritas_app():
    """Gibt die globale VeritasApp-Instanz zur√ºck."""
    global _veritas_app_instance
    return _veritas_app_instance

class ModernVeritasApp:
    """
    Moderne Veritas App mit integrierter Chat-GUI und UDS3 v3.0 Support
    """
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("üí¨ Veritas Chat - Moderne GUI")
        self.root.geometry("900x700")
        self.root.minsize(700, 500)
        
        # Globale App-Instanz setzen
        global _veritas_app_instance
        _veritas_app_instance = self
        
        # Initialisierung
        self._init_directories()
        self._init_gui_state()
        self._init_threading()
        self._init_chat_persistence()  # ‚ú® NEU: Chat-Persistierung
        
        # GUI Setup
        self.setup_styles()
        self.create_layout()
        self.setup_bindings()
        
        # Startup
        self.load_last_chat()
        self.update_recent_chats_dropdown()
        self.check_api_status()
        
        # ‚ú® NEU: Session-Restore-Dialog anzeigen
        self._show_session_restore_dialog()
        
        logger.info(f"Moderne Veritas App v{__version__} initialisiert")
    
    def _init_directories(self):
        """Initialisiert Verzeichnisse"""
        self.chats_dir = os.path.join("data", "chats")
        if not os.path.exists(self.chats_dir):
            os.makedirs(self.chats_dir)
        
        self.last_chat_file = os.path.join(self.chats_dir, ".last_chat")
    
    def _init_gui_state(self):
        """Initialisiert GUI-Status"""
        self.current_chat_id = None
        self.current_chat_file = None
        self.chat_messages = []
        self.auto_save_enabled = True
        self.selected_llm = None  # Wird dynamisch vom Backend geladen
        self.selected_mode = "ask"
        self.context_files = []
        self.api_connected = False
        self.session_id = None  # API Session ID
        
        # ‚ú® NEU: Chat-Persistierung
        from uuid import uuid4
        self.current_session_id = str(uuid4())  # Eindeutige Session-ID
        
        # Backend Capabilities
        self.capabilities: Dict[str, Any] = {}
        
        # Quality-Enhanced Chat Integration
        self.quality_formatter = None
        self.quality_enabled = True
        self._init_quality_enhancement()
    
    def _init_threading(self):
        """Initialisiert Thread-Kommunikation"""
        self.ui_queue = queue.Queue()
        self.chat_windows_lock = threading.Lock()
        self._setup_queue_processing()
    
    def _setup_queue_processing(self):
        """Richtet Queue-Verarbeitung ein"""
        def process_queue():
            try:
                while True:
                    try:
                        task = self.ui_queue.get_nowait()
                        self._handle_queue_task(task)
                        self.ui_queue.task_done()
                    except queue.Empty:
                        break
            except Exception as e:
                logger.error(f"Fehler beim Verarbeiten der UI-Queue: {e}")
            
            self.root.after(100, process_queue)
        
        self.root.after(100, process_queue)
    
    def _handle_queue_task(self, task):
        """Behandelt Queue-Tasks"""
        task_type = task.get('type')
        
        if task_type == 'send_message':
            self._handle_send_message_task(task)
        elif task_type == 'receive_response':
            self._handle_receive_response_task(task)
        elif task_type == 'update_status':
            self._handle_update_status_task(task)
        else:
            logger.warning(f"Unbekannter Queue-Task-Typ: {task_type}")
    
    def _init_quality_enhancement(self):
        """Initialisiert Quality-Enhanced-Features"""
        try:
            from quality_enhanced_chat_formatter import QualityEnhancedResponseFormatter
            self.quality_formatter = QualityEnhancedResponseFormatter()
            logger.info("‚úÖ Quality-Enhanced Chat Formatter geladen")
        except ImportError as e:
            logger.warning(f"Quality-Enhanced Features nicht verf√ºgbar: {e}")
            self.quality_formatter = None
            self.quality_enabled = False
    
    def _init_chat_persistence(self):
        """Initialisiert Chat-Persistierung Service"""
        try:
            from backend.services.chat_persistence_service import ChatPersistenceService
            from shared.chat_schema import ChatSession
            
            self.chat_persistence = ChatPersistenceService()
            self.chat_session = ChatSession(
                session_id=self.current_session_id,
                llm_model=self.selected_llm or "llama3.1:8b"
            )
            
            logger.info(f"‚úÖ Chat-Persistierung initialisiert (Session: {self.current_session_id[:8]}...)")
            
            # Auto-Backup beim Start (falls n√∂tig)
            self.chat_persistence.auto_backup_if_needed()
            
        except Exception as e:
            logger.error(f"‚ùå Chat-Persistierung konnte nicht initialisiert werden: {e}")
            self.chat_persistence = None
            self.chat_session = None
    
    def _show_session_restore_dialog(self):
        """Zeigt Session-Restore-Dialog beim Start"""
        try:
            # Pr√ºfe ob Chat-Persistence verf√ºgbar
            if not hasattr(self, 'chat_persistence') or not self.chat_persistence:
                logger.info("Chat-Persistence nicht verf√ºgbar, √ºberspringe Session-Restore")
                return
            
            # Lade Settings
            import os
            import json
            settings_file = os.path.join("data", "session_restore_settings.json")
            auto_restore = False
            
            if os.path.exists(settings_file):
                try:
                    with open(settings_file, 'r') as f:
                        settings = json.load(f)
                        auto_restore = settings.get('auto_restore', False)
                except:
                    pass
            
            # Auto-Restore: Lade letzte Session ohne Dialog
            if auto_restore:
                sessions = self.chat_persistence.list_chat_sessions(limit=1, sort_by='updated_at', reverse=True)
                if sessions:
                    session_id = sessions[0]['session_id']
                    self._restore_session(session_id)
                    logger.info(f"‚úÖ Auto-Restore: Session {session_id[:8]}... wiederhergestellt")
                    return
            
            # Zeige Dialog
            from frontend.ui.veritas_ui_session_dialog import show_session_restore_dialog
            
            # Dialog nach kurzem Delay anzeigen (damit GUI vollst√§ndig geladen ist)
            self.root.after(500, lambda: self._show_restore_dialog_delayed())
            
        except Exception as e:
            logger.error(f"Fehler beim Anzeigen des Session-Restore-Dialogs: {e}")
    
    def _show_restore_dialog_delayed(self):
        """Zeigt Session-Restore-Dialog (delayed)"""
        try:
            from frontend.ui.veritas_ui_session_dialog import show_session_restore_dialog
            
            session_id = show_session_restore_dialog(self.root, self.chat_persistence)
            
            if session_id:
                # Session wiederherstellen
                self._restore_session(session_id)
                logger.info(f"‚úÖ Session wiederhergestellt: {session_id[:8]}...")
            else:
                # Neuen Chat starten (bereits geschehen)
                logger.info("üÜï Neuer Chat gestartet")
                
        except Exception as e:
            logger.error(f"Fehler im Session-Restore-Dialog: {e}")
    
    def _restore_session(self, session_id: str):
        """Stellt eine Session wieder her"""
        try:
            # Lade Session
            loaded_session = self.chat_persistence.load_chat_session(session_id)
            
            if not loaded_session:
                messagebox.showerror("Fehler", f"Session konnte nicht geladen werden: {session_id[:8]}...")
                return
            
            # Ersetze aktuelle Session
            self.chat_session = loaded_session
            self.current_session_id = loaded_session.session_id
            
            # Konvertiere Messages zu chat_messages Format
            self.chat_messages = []
            for msg in loaded_session.messages:
                self.chat_messages.append({
                    'role': msg.role,
                    'content': msg.content,
                    'timestamp': msg.timestamp.strftime('%H:%M:%S'),
                    'metadata': msg.metadata
                })
            
            # Update Display
            self.update_chat_display()
            self.update_message_count()
            
            # Status-Update
            self.status_var.set(f"Session wiederhergestellt: {loaded_session.title}")
            
            logger.info(f"‚úÖ Session wiederhergestellt: {loaded_session.title} ({len(loaded_session.messages)} Nachrichten)")
            
        except Exception as e:
            logger.error(f"Fehler beim Wiederherstellen der Session: {e}")
            messagebox.showerror("Fehler", f"Session-Wiederherstellung fehlgeschlagen:\n{e}")
    
    def _open_session_manager(self):
        """√ñffnet Session-Manager-Fenster"""
        try:
            from frontend.ui.veritas_ui_session_manager import show_session_manager
            
            # √ñffne Session-Manager mit Callback
            show_session_manager(
                self.root,
                self.chat_persistence,
                on_session_opened=self._restore_session
            )
            
            logger.info("Session-Manager ge√∂ffnet")
            
        except Exception as e:
            logger.error(f"Fehler beim √ñffnen des Session-Managers: {e}")
            messagebox.showerror("Fehler", f"Session-Manager konnte nicht ge√∂ffnet werden:\n{e}")

    
    def setup_styles(self):
        """Konfiguriert moderne Styles"""
        self.style = ttk.Style()
        self.style.theme_use('clam')
        
        # Farbschema mit Quality-Enhancement
        self.colors = {
            'primary': '#2E86AB',
            'success': '#28A745',
            'warning': '#F18F01',
            'danger': '#C73E1D',
            'secondary': '#6C757D',
            'light': '#F8F9FA',
            'dark': '#343A40',
            'chat_bg': '#FFFFFF',
            'input_bg': '#F7F7F7',
            # Quality-Enhancement Farben
            'quality_high': '#4CAF50',
            'quality_medium': '#FF9800',
            'quality_low': '#F44336',
            'quality_bg': '#F8FFF8',
            'sources_bg': '#F0F8FF',
            'suggestions_bg': '#FFFAF0'
        }
        
        # Custom Styles
        self.style.configure('Header.TLabel', font=('Segoe UI', 12, 'bold'))
        self.style.configure('Status.TLabel', font=('Segoe UI', 9))
        self.style.configure('Chat.TFrame', relief='flat', borderwidth=1)
        self.style.configure('Control.TFrame', relief='ridge', borderwidth=1)
        self.style.configure('Compact.TCombobox', font=('Segoe UI', 8))
        self.style.configure('Compact.TLabel', font=('Segoe UI', 8))
    
    def create_layout(self):
        """Erstellt das Haupt-Layout"""
        self.create_compact_header()
        self.create_chat_area()
        self.create_input_area()
        self.create_status_bar()
    
    def create_compact_header(self):
        """Erstellt kompakten Header"""
        header_frame = ttk.Frame(self.root)
        header_frame.pack(fill=tk.X, padx=5, pady=2)
        
        # Linke Seite: Men√º
        left_section = ttk.Frame(header_frame)
        left_section.pack(side=tk.LEFT)
        
        self.menu_button = ttk.Button(left_section, text="‚ò∞", width=3,
                                     command=self.show_hamburger_menu)
        self.menu_button.pack(side=tk.LEFT, padx=(0, 5))
        
        # Mittlere Sektion: Chat-Steuerung
        middle_section = ttk.Frame(header_frame)
        middle_section.pack(side=tk.LEFT, padx=8)
        
        ttk.Button(middle_section, text="‚ûï Neu", command=self.new_chat, 
                  width=8).pack(side=tk.LEFT, padx=1)
        
        self.recent_chats_var = tk.StringVar(value="K√ºrzliche Chats")
        self.recent_chats_combo = ttk.Combobox(
            middle_section,
            textvariable=self.recent_chats_var,
            state="readonly",
            width=14,
            font=('Segoe UI', 9)
        )
        self.recent_chats_combo.pack(side=tk.LEFT, padx=1)
        self.recent_chats_combo.bind('<<ComboboxSelected>>', self.on_recent_chat_selected)
        
        # Rechte Seite: Status und UDS3-Info
        right_section = ttk.Frame(header_frame)
        right_section.pack(side=tk.RIGHT)
        
        # UDS3 Status
        uds3_status = "üî• UDS3" if self.is_uds3_available() else "‚öôÔ∏è Standard"
        self.uds3_label = ttk.Label(right_section, text=uds3_status, 
                                   style='Compact.TLabel',
                                   foreground=self.colors['success'] if self.is_uds3_available() else self.colors['secondary'])
        self.uds3_label.pack(side=tk.RIGHT, padx=5)
        
        # Nachrichten-Z√§hler
        self.message_count_label = ttk.Label(right_section, text="0", 
                                            style='Compact.TLabel',
                                            foreground=self.colors['secondary'])
        self.message_count_label.pack(side=tk.RIGHT, padx=5)
        
        # API-Status
        self.api_status_label = ttk.Label(right_section, text="üî¥", 
                                         style='Compact.TLabel')
        self.api_status_label.pack(side=tk.RIGHT, padx=2)
    
    def create_chat_area(self):
        """Erstellt Chat-Bereich"""
        chat_container = ttk.Frame(self.root)
        chat_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
        
        # Chat-Display
        self.chat_text = scrolledtext.ScrolledText(
            chat_container,
            wrap=tk.WORD,
            font=('Segoe UI', 10),
            bg=self.colors['chat_bg'],
            relief='flat',
            borderwidth=1,
            state='disabled'
        )
        self.chat_text.pack(fill=tk.BOTH, expand=True)
        
        # Chat-Tags f√ºr Styling
        self.setup_chat_tags()
    
    def setup_chat_tags(self):
        """Konfiguriert Chat-Text-Tags mit Quality-Enhancement-Support"""
        self.chat_text.tag_configure("user", foreground="#0066CC", font=('Segoe UI', 10, 'bold'))
        self.chat_text.tag_configure("assistant", foreground="#006600", font=('Segoe UI', 10))
        self.chat_text.tag_configure("system", foreground="#666666", font=('Segoe UI', 9, 'italic'))
        self.chat_text.tag_configure("timestamp", foreground="#999999", font=('Segoe UI', 8))
        self.chat_text.tag_configure("error", foreground="#CC0000", font=('Segoe UI', 10, 'bold'))
        self.chat_text.tag_configure("uds3", foreground="#FF6600", font=('Segoe UI', 9, 'bold'))
        
        # Quality-Enhancement-Tags
        self.chat_text.tag_configure("quality", 
                                   foreground="#4CAF50", 
                                   font=('Segoe UI', 9, 'italic'),
                                   background="#F8FFF8")
        self.chat_text.tag_configure("sources", 
                                   foreground="#2196F3", 
                                   font=('Segoe UI', 9),
                                   background="#F0F8FF")
        self.chat_text.tag_configure("suggestions", 
                                   foreground="#FF9800", 
                                   font=('Segoe UI', 9, 'italic'),
                                   background="#FFFAF0")
    
    def create_input_area(self):
        """Erstellt Eingabe-Bereich"""
        input_container = ttk.Frame(self.root)
        input_container.pack(fill=tk.X, padx=5, pady=2)
        
        # Kontext-Zeile
        top_row = ttk.Frame(input_container)
        top_row.pack(fill=tk.X, pady=(0, 2))
        
        self.add_doc_button = ttk.Button(top_row, text="üìé Dokument hinzuf√ºgen", 
                                        command=self.add_document, width=20)
        self.add_doc_button.pack(side=tk.LEFT)
        
        # UDS3 Security Button
        if self.is_uds3_available():
            self.classify_button = ttk.Button(top_row, text="üîí Klassifizieren", 
                                            command=self.classify_document, width=15)
            self.classify_button.pack(side=tk.LEFT, padx=(5, 0))
        
        self.context_files_frame = ttk.Frame(top_row)
        self.context_files_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))
        
        # Haupt-Eingabe
        input_frame = ttk.Frame(input_container)
        input_frame.pack(fill=tk.X)
        
        self.input_text = tk.Text(
            input_frame,
            height=3,
            wrap=tk.WORD,
            font=('Segoe UI', 10),
            bg=self.colors['input_bg'],
            relief='solid',
            borderwidth=1
        )
        self.input_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 2))
        
        send_frame = ttk.Frame(input_frame)
        send_frame.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.send_button = ttk.Button(send_frame, text="üì§\nSenden", 
                                     command=self.send_message, width=10)
        self.send_button.pack(fill=tk.BOTH, expand=True)
        
        # Steuerung-Zeile
        bottom_row = ttk.Frame(input_container)
        bottom_row.pack(fill=tk.X, pady=(2, 0))
        
        # Frage-Modus Auswahl
        ttk.Label(bottom_row, text="üìã", style='Compact.TLabel').pack(side=tk.LEFT, padx=(0, 2))
        
        self.mode_var = tk.StringVar(value="veritas")
        # Dynamisch Frage-Modi laden
        logger.info("üîÑ Lade Frage-Modi f√ºr GUI...")
        available_question_methods = self.get_available_question_methods()
        mode_values = [method['display'] for method in available_question_methods]
        self.question_methods_data = {method['display']: method for method in available_question_methods}
        
        logger.info(f"üìã GUI: {len(mode_values)} Modi geladen: {mode_values}")
        
        self.mode_combo = ttk.Combobox(
            bottom_row,
            textvariable=self.mode_var,
            values=mode_values,
            state="readonly",
            width=15,
            font=('Segoe UI', 8)
        )
        self.mode_combo.pack(side=tk.LEFT, padx=(0, 5))
        self.mode_combo.bind('<<ComboboxSelected>>', self.on_mode_change)
        
        # Setze Standard-Wert
        if mode_values:
            self.mode_combo.set(mode_values[0])
            logger.info(f"üìã Standard-Modus gesetzt: {mode_values[0]}")
        else:
            logger.warning("‚ö†Ô∏è Keine Modi verf√ºgbar f√ºr Dropdown")
        
        # LLM-Auswahl
        ttk.Label(bottom_row, text="ü§ñ", style='Compact.TLabel').pack(side=tk.LEFT, padx=(5, 2))
        
        # Dynamisch LLM-Modelle laden
        available_models = self.get_available_llm_models()
        
        # Validiere selected_llm und setze Default wenn n√∂tig
        if not self.selected_llm or self.selected_llm not in available_models:
            if available_models:
                self.selected_llm = available_models[0]
                logger.info(f"üéØ Default-Modell gesetzt: {self.selected_llm}")
        
        self.llm_var = tk.StringVar(value=self.selected_llm)
        
        self.llm_combo = ttk.Combobox(
            bottom_row, 
            textvariable=self.llm_var,
            values=available_models,
            state="readonly",
            width=15,
            font=('Segoe UI', 8)
        )
        self.llm_combo.pack(side=tk.LEFT)
        self.llm_combo.bind('<<ComboboxSelected>>', self.on_llm_change)
        
        # Eingabe-Bindings
        self.input_text.bind('<Control-Return>', lambda e: self.send_message())
        self.input_text.bind('<KeyPress>', self.on_typing)
    
    def create_status_bar(self):
        """Erstellt Status-Bar"""
        status_frame = ttk.Frame(self.root)
        status_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=5, pady=1)
        
        # Verbindungsstatus
        self.connection_status = ttk.Label(status_frame, text="üî¥ Nicht verbunden",
                                         style='Compact.TLabel', foreground=self.colors['secondary'])
        self.connection_status.pack(side=tk.LEFT)
        
        # API-Status f√ºr Anfragen
        self.api_status_label = ttk.Label(status_frame, text="‚ö™",
                                        style='Compact.TLabel')
        self.api_status_label.pack(side=tk.LEFT, padx=(5, 0))
        
        # Status-Variable f√ºr Text-Updates
        self.status_var = tk.StringVar()
        self.status_var.set("Bereit")
        
        # Chat-Info
        self.chat_info_label = ttk.Label(status_frame, textvariable=self.status_var,
                                       style='Compact.TLabel', foreground=self.colors['secondary'])
        self.chat_info_label.pack(side=tk.LEFT, padx=15)
        
        # Auto-Speicher
        self.auto_save_label = ttk.Label(status_frame, text="üíæ Auto-Speichern", 
                                        style='Compact.TLabel', 
                                        foreground=self.colors['secondary'])
        self.auto_save_label.pack(side=tk.RIGHT, padx=5)
        
        # Quality-Enhancement Status
        if self.quality_enabled:
            quality_text = "‚ö° Quality-Enhanced" if self.quality_formatter else "‚ö° Quality (Error)"
            quality_color = self.colors['success'] if self.quality_formatter else self.colors['danger']
            self.quality_status_label = ttk.Label(status_frame, text=quality_text,
                                                 style='Compact.TLabel',
                                                 foreground=quality_color)
            self.quality_status_label.pack(side=tk.RIGHT, padx=5)
        
        # Version mit UDS3 Status
        version_text = f"v{__version__}"
        if self.is_uds3_available():
            version_text += " | UDS3"
        
        version_label = ttk.Label(status_frame, text=version_text, 
                                 style='Compact.TLabel', 
                                 foreground=self.colors['secondary'])
        version_label.pack(side=tk.RIGHT, padx=5)
    
    def setup_bindings(self):
        """Setup Event-Bindings"""
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        # Keyboard shortcuts
        self.root.bind('<Control-n>', lambda e: self.new_chat())
        self.root.bind('<Control-o>', lambda e: self.load_chat())
        self.root.bind('<Control-s>', lambda e: self.save_chat())
        self.root.bind('<F5>', lambda e: self.check_api_status())
    
    def show_hamburger_menu(self):
        """Zeigt Hamburger-Men√º"""
        try:
            menu = tk.Menu(self.root, tearoff=0)
            
            # Chat-Funktionen
            menu.add_command(label="‚ûï Neuer Chat", command=self.new_chat)
            menu.add_command(label="üìÅ Chat √∂ffnen", command=self.load_chat)
            menu.add_command(label="üíæ Chat speichern", command=self.save_chat)
            menu.add_command(label="üìã Chat exportieren", command=self.export_chat)
            
            # ‚ú® NEU: Session-Verwaltung
            try:
                if hasattr(self, 'chat_persistence') and self.chat_persistence:
                    menu.add_separator()
                    menu.add_command(label="üìÅ Sessions verwalten", command=self._open_session_manager)
            except Exception as e:
                logger.warning(f"Session-Manager Men√º √ºbersprungen: {e}")
            
            menu.add_separator()
            
            # UDS3 Funktionen
            try:
                if self.is_uds3_available():
                    menu.add_command(label="üî• UDS3 Funktionen:", state="disabled")
                    menu.add_command(label="   üîí Dokument klassifizieren", command=self.classify_document)
                    menu.add_command(label="   üìä Qualit√§t bewerten", command=self.assess_quality)
                    menu.add_command(label="   üì¶ Batch verarbeiten", command=self.batch_process)
                    menu.add_separator()
            except Exception as e:
                logger.warning(f"UDS3-Men√º-Eintr√§ge √ºbersprungen: {e}")
            
            # Einstellungen
            try:
                auto_save_text = "‚ùå Auto-Speichern" if self.auto_save_enabled else "‚úÖ Auto-Speichern"
                menu.add_command(label=auto_save_text, command=self.toggle_auto_save)
            except Exception as e:
                logger.warning(f"Auto-Save Men√º √ºbersprungen: {e}")
            
            # Quality-Enhancement Toggle
            try:
                if hasattr(self, 'quality_formatter'):
                    quality_text = "‚ùå Quality-Enhancement" if self.quality_enabled else "‚úÖ Quality-Enhancement"
                    menu.add_command(label=quality_text, command=self.toggle_quality_enhancement)
            except Exception as e:
                logger.warning(f"Quality-Enhancement Men√º √ºbersprungen: {e}")
            
            try:
                menu.add_command(label="‚öôÔ∏è Einstellungen", command=self.open_settings)
                menu.add_command(label="üîß API-Verbindung pr√ºfen", command=self.check_api_status)
            except Exception as e:
                logger.warning(f"Einstellungen-Men√º √ºbersprungen: {e}")
            
            menu.add_separator()
            
            # IMMI-Karte
            try:
                menu.add_command(label="üó∫Ô∏è IMMI-Karte √∂ffnen", command=self.open_immi_map)
                menu.add_separator()
            except Exception as e:
                logger.warning(f"IMMI-Karte Men√º √ºbersprungen: {e}")
            
            # Info & Hilfe
            menu.add_command(label="‚ÑπÔ∏è √úber Veritas", command=self.show_about)
            menu.add_command(label="‚ùì Hilfe", command=self.show_help)
            
            menu.add_separator()
            menu.add_command(label="‚ùå Beenden", command=self.on_closing)
            
            # Menu anzeigen
            try:
                x = self.menu_button.winfo_rootx()
                y = self.menu_button.winfo_rooty() + self.menu_button.winfo_height()
                menu.tk_popup(x, y)
            except Exception as e:
                logger.error(f"Fehler beim Anzeigen des Men√ºs: {e}")
                messagebox.showerror("Men√º-Fehler", f"Konnte Men√º nicht anzeigen:\n{e}")
            finally:
                menu.grab_release()
        except Exception as e:
            logger.error(f"Fehler in show_hamburger_menu: {e}")
            messagebox.showerror("Fehler", f"Hamburger-Men√º konnte nicht erstellt werden:\n{e}")
    
    def new_chat(self):
        """Startet neuen Chat"""
        if self.chat_messages and messagebox.askyesno("Neuer Chat", 
                                                     "Aktuellen Chat verwerfen und neu starten?"):
            self.chat_messages = []
            self.current_chat_id = None
            self.current_chat_file = None
            
            self.update_chat_display()
            self.update_title("Neuer Chat")
            self.update_message_count()
            
            self.add_system_message("üÜï Neuer Chat gestartet")
    
    def load_chat(self):
        """L√§dt Chat aus Datei"""
        filepath = filedialog.askopenfilename(
            title="Chat-Datei √∂ffnen",
            initialdir=self.chats_dir,
            filetypes=[("JSON-Dateien", "*.json"), ("Alle Dateien", "*.*")]
        )
        
        if filepath:
            self.load_chat_file(filepath)
    
    def load_chat_file(self, filepath):
        """L√§dt spezifischen Chat"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            self.chat_messages = data.get('messages', [])
            self.current_chat_file = filepath
            self.current_chat_id = data.get('chat_id', os.path.basename(filepath))
            
            title = data.get('title', 'Unbenannter Chat')
            self.update_title(title)
            self.update_chat_display()
            self.update_message_count()
            
            self.update_recent_chats_dropdown()
            
            self.add_system_message(f"üìÅ Chat geladen: {os.path.basename(filepath)}")
            
        except Exception as e:
            messagebox.showerror("Fehler", f"Konnte Chat nicht laden:\n{e}")
    
    def save_chat(self):
        """Speichert aktuellen Chat"""
        if not self.chat_messages:
            messagebox.showinfo("Info", "Keine Nachrichten zum Speichern")
            return
        
        if not self.current_chat_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"chat_{timestamp}.json"
            self.current_chat_file = os.path.join(self.chats_dir, filename)
        
        try:
            chat_data = {
                'chat_id': self.current_chat_id or f"chat_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                'title': self.root.title().replace('üí¨ ', '').replace(' - Veritas Chat', ''),
                'messages': self.chat_messages,
                'created_at': datetime.now().isoformat(),
                'llm_model': self.selected_llm,
                'uds3_available': self.is_uds3_available()
            }
            
            with open(self.current_chat_file, 'w', encoding='utf-8') as f:
                json.dump(chat_data, f, ensure_ascii=False, indent=2)
            
            self.update_recent_chats_dropdown()
            self.add_system_message(f"üíæ Chat gespeichert: {os.path.basename(self.current_chat_file)}")
            
        except Exception as e:
            messagebox.showerror("Fehler", f"Konnte Chat nicht speichern:\n{e}")
    
    def export_chat(self):
        """Exportiert Chat als Office-Dokument (Word/Excel) oder Textdatei"""
        if not self.chat_messages:
            messagebox.showinfo("Info", "Keine Nachrichten zum Exportieren")
            return
        
        # Pr√ºfe ob Office Export verf√ºgbar ist
        if OFFICE_EXPORT_AVAILABLE:
            try:
                # Zeige Export-Dialog (Word/Excel mit Optionen)
                dialog = ExportDialog(self.root, self.chat_messages)
                result = dialog.show()
                
                if result:
                    # Export durchf√ºhren
                    export_service = OfficeExportService()
                    format_type = result.get('format', 'docx')
                    period = result.get('period', 'all')
                    include_metadata = result.get('include_metadata', True)
                    include_sources = result.get('include_sources', True)
                    custom_filename = result.get('filename')
                    
                    try:
                        if format_type == 'docx':
                            filepath = export_service.export_to_word(
                                messages=self.chat_messages,
                                filename=custom_filename,
                                period=period,
                                include_metadata=include_metadata,
                                include_sources=include_sources
                            )
                        else:  # xlsx
                            filepath = export_service.export_to_excel(
                                messages=self.chat_messages,
                                filename=custom_filename,
                                period=period
                            )
                        
                        messagebox.showinfo(
                            "Export erfolgreich", 
                            f"Chat exportiert nach:\n{filepath}\n\n"
                            f"Format: {format_type.upper()}\n"
                            f"Zeitraum: {period}"
                        )
                        
                    except Exception as e:
                        logger.error(f"Export-Fehler: {e}")
                        messagebox.showerror("Export-Fehler", f"Konnte nicht exportieren:\n{e}")
                        
            except Exception as e:
                logger.error(f"Dialog-Fehler: {e}")
                # Fallback zu Text-Export
                self._export_chat_as_text()
        else:
            # Fallback: Text-Export
            self._export_chat_as_text()
    
    def _export_chat_as_text(self):
        """Fallback: Exportiert Chat als einfache Textdatei"""
        filepath = filedialog.asksaveasfilename(
            title="Chat exportieren",
            defaultextension=".txt",
            filetypes=[("Textdateien", "*.txt"), ("Alle Dateien", "*.*")]
        )
        
        if filepath:
            try:
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(f"Veritas Chat Export v{__version__}\n")
                    f.write(f"========================================\n\n")
                    f.write(f"Exportiert am: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}\n")
                    f.write(f"LLM-Modell: {self.selected_llm}\n")
                    f.write(f"UDS3 v3.0: {'Verf√ºgbar' if self.is_uds3_available() else 'Nicht verf√ºgbar'}\n\n")
                    
                    for msg in self.chat_messages:
                        role = msg.get('role', 'unknown').title()
                        content = msg.get('content', '')
                        timestamp = msg.get('timestamp', '')
                        
                        f.write(f"[{timestamp}] {role}:\n")
                        f.write(f"{content}\n\n")
                        f.write("-" * 50 + "\n\n")
                
                messagebox.showinfo("Export", f"Chat exportiert nach:\n{filepath}")
                
            except Exception as e:
                messagebox.showerror("Fehler", f"Konnte Chat nicht exportieren:\n{e}")
    
    def send_message(self):
        """Sendet Nachricht"""
        message = self.input_text.get('1.0', tk.END).strip()
        if not message:
            return
        
        # Nachricht zur Chat-Historie hinzuf√ºgen
        user_message = {
            'role': 'user',
            'content': message,
            'timestamp': datetime.now().strftime('%H:%M:%S'),
            'mode': self.selected_mode,
            'llm': self.selected_llm
        }
        self.chat_messages.append(user_message)
        
        # ‚ú® NEU: Nachricht zur Chat-Session hinzuf√ºgen
        if hasattr(self, 'chat_session') and self.chat_session:
            self.chat_session.add_message(
                role='user',
                content=message,
                metadata={
                    'mode': self.selected_mode,
                    'llm': self.selected_llm
                }
            )
            # Auto-Save
            if hasattr(self, 'chat_persistence') and self.chat_persistence:
                self.chat_persistence.save_chat_session(self.chat_session)
        
        # Eingabe leeren
        self.input_text.delete('1.0', tk.END)
        
        # Chat-Display aktualisieren
        self.update_chat_display()
        self.update_message_count()
        
        # Auto-Speichern (legacy)
        if self.auto_save_enabled:
            self.auto_save_chat()
        
        # API-Anfrage √ºber Queue
        task = {
            'type': 'send_message',
            'message': message,
            'mode': self.selected_mode,
            'llm': self.selected_llm
        }
        self.ui_queue.put(task)
    
    def _handle_send_message_task(self, task):
        """Behandelt Nachricht-Senden-Task"""
        try:
            self.api_status_label.config(text="üîÑ")
            
            # UDS3 Integration - erweiterte Verarbeitung
            if self.is_uds3_available() and task['mode'] == 'classify':
                self._handle_uds3_classification(task)
            else:
                self._send_to_api(task)
                
        except Exception as e:
            self.add_error_message(f"Fehler beim Senden: {e}")
    
    def _handle_uds3_classification(self, task):
        """Behandelt UDS3-Klassifizierung"""
        try:
            message = task['message']
            
            # Sicherheitsklassifizierung
            if self.security_manager:
                security_result = self.security_manager.classify_administrative_document(message, {})
                
                # Qualit√§tsbewertung
                quality_result = self.quality_manager.assess_content_quality(message, 'text') if self.quality_manager else None
                
                # Ergebnis formatieren
                response = f"üîí UDS3 Sicherheitsklassifizierung:\n"
                response += f"‚Ä¢ Sicherheitsstufe: {security_result.get('security_level', 'UNBEKANNT')}\n"
                response += f"‚Ä¢ Administrative Klassifizierung: {security_result.get('admin_classification', 'UNBEKANNT')}\n"
                response += f"‚Ä¢ Begr√ºndung: {security_result.get('reasoning', 'Keine Begr√ºndung')}\n"
                
                if quality_result:
                    response += f"\nüìä Qualit√§tsbewertung:\n"
                    response += f"‚Ä¢ Qualit√§tsstufe: {quality_result.get('quality_level', 'UNBEKANNT')}\n"
                    response += f"‚Ä¢ Score: {quality_result.get('score', 0):.2f}\n"
                    response += f"‚Ä¢ Details: {quality_result.get('reasoning', 'Keine Details')}\n"
                
                # Moderne Queue-basierte Response-Behandlung
                if hasattr(self, 'main_window') and self.main_window:
                    # UDS3 Response-Daten strukturieren
                    uds3_response = {
                        'content': response,
                        'sources': [],
                        'rag_metadata': {
                            'security_classification': security_result,
                            'quality_assessment': quality_result,
                            'uds3_processed': True
                        },
                        'citations_info': {},
                        'turn_id': f"uds3_{int(time.time())}"
                    }
                    
                    # Queue-Message senden
                    queue_message = QueueMessage(
                        sender_id="UDS3",
                        message_type="backend_response",
                        data=uds3_response
                    )
                    
                    self.main_window.queue.put(queue_message)
                    logger.info(f"UDS3-Response an Hauptfenster-Queue gesendet")
                else:
                    # Fallback f√ºr alte Architektur
                    if self.root and hasattr(self.root, 'winfo_exists') and self.root.winfo_exists():
                        self.root.after(500, lambda: self.receive_api_response(response, "uds3"))
            else:
                self.add_error_message("UDS3 SecurityManager nicht verf√ºgbar")
                
        except Exception as e:
            self.add_error_message(f"UDS3 Klassifizierungsfehler: {e}")
    
    def _send_to_api(self, task):
        """Sendet Nachricht an API - Echte Implementierung"""
        try:
            message = task['message']
            mode = task.get('mode', 'veritas')
            llm = task.get('llm', 'llama3.1:8b')
            
            # API-Session erstellen falls nicht vorhanden
            if not hasattr(self, 'session_id') or not self.session_id:
                if not self._create_api_session():
                    self.add_error_message("Fehler: Keine API-Session verf√ºgbar")
                    return
            
            # Endpoint basierend auf gew√§hltem Modus bestimmen
            endpoint = "/ask"  # Standard
            
            # Pr√ºfe aktuellen Modus
            if hasattr(self, 'current_question_mode') and self.current_question_mode:
                mode_key = self.current_question_mode.get('key', 'veritas')
                endpoints = self.current_question_mode.get('endpoints', ['/ask'])
                
                if endpoints:
                    endpoint = endpoints[0]  # Verwende ersten verf√ºgbaren Endpoint
                    
                logger.info(f"Verwende Modus: {mode_key}, Endpoint: {endpoint}")
            
            # API-Payload entsprechend dem FastAPI Schema
            payload = {
                "question": message,
                "session_id": self.session_id,
                "temperature": self.temperature_var.get() if hasattr(self, 'temperature_var') else 0.7,
                "max_tokens": self.max_tokens_var.get() if hasattr(self, 'max_tokens_var') else 500,
                "top_p": self.top_p_var.get() if hasattr(self, 'top_p_var') else 0.9,
                "model": llm,
                "collection": None  # Optional: spezifische Collection
            }
            
            # üÜï CHAT-HISTORY INTEGRATION: Sende aktuelle Session-History
            if hasattr(self, 'chat_session') and self.chat_session and hasattr(self.chat_session, 'messages'):
                try:
                    # Extrahiere letzte 10 Messages f√ºr Context
                    recent_messages = self.chat_session.messages[-10:] if len(self.chat_session.messages) > 10 else self.chat_session.messages
                    
                    # Konvertiere zu API-Format
                    chat_history = [
                        {
                            'role': msg.role,
                            'content': msg.content
                        }
                        for msg in recent_messages
                    ]
                    
                    # F√ºge zur Payload hinzu (nur f√ºr /ask Endpoint)
                    if endpoint == "/ask" and len(chat_history) > 0:
                        payload["chat_history"] = chat_history
                        logger.info(f"üìù Chat-History hinzugef√ºgt: {len(chat_history)} Messages")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Chat-History-Integration fehlgeschlagen: {e}")
            
            # Spezielle Payload-Anpassungen f√ºr verschiedene Modi
            if endpoint == "/vpb/ask":
                payload = {
                    "question": message,
                    "analysis_depth": "standard",
                    "include_suggestions": True,
                    "session_id": self.session_id
                }
            elif endpoint in ["/covina/ask", "/covina/search"]:
                payload["quality_level"] = "high"
                payload["enhancement_mode"] = "full"
            
            # Status-Update
            self.api_status_label.config(text="üì§")
            self.status_var.set("Sende Nachricht an API...")
            
            # API-Anfrage senden
            logger.info(f"Sende API-Anfrage an {API_BASE_URL}{endpoint}")
            logger.debug(f"Payload: {json.dumps(payload, indent=2)}")
            
            api_response = requests.post(
                f"{API_BASE_URL}{endpoint}",
                json=payload,
                timeout=60,  # Erh√∂htes Timeout f√ºr komplexe Anfragen
                headers={
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                }
            )
            
            if api_response.status_code == 200:
                response_data = api_response.json()
                logger.info(f"API-Response erfolgreich: {api_response.status_code}")
                logger.debug(f"Response: {json.dumps(response_data, indent=2)}")
                
                # Antwort verarbeiten
                if endpoint == "/vpb/ask":
                    # VPB-spezifische Response
                    answer = response_data.get('answer', 'Keine Antwort erhalten.')
                    sources = response_data.get('sources', [])
                    process_found = response_data.get('process_found', False)
                    suggestions = response_data.get('suggestions', [])
                    
                    # VPB-Antwort formatieren
                    formatted_response = f"üèõÔ∏è **VPB-Analyse:**\n\n{answer}"
                    if process_found:
                        formatted_response += f"\n\n‚úÖ **Prozess gefunden**"
                    if suggestions:
                        formatted_response += f"\n\nüí° **Vorschl√§ge:**\n" + "\n".join([f"‚Ä¢ {s}" for s in suggestions])
                    
                    final_answer = formatted_response
                else:
                    # Standard RAG Response
                    answer = response_data.get('answer', 'Keine Antwort erhalten.')
                    enhanced_answer = response_data.get('enhanced_answer')
                    quality_summary = response_data.get('quality_summary')
                    sources = response_data.get('sources', [])
                    suggestions = response_data.get('suggestions', [])
                    confidence_score = response_data.get('confidence_score', 0.0)
                    
                    # Enhanced Answer verwenden falls verf√ºgbar
                    final_answer = enhanced_answer if enhanced_answer else answer
                    
                    # Quality Summary hinzuf√ºgen falls verf√ºgbar
                    if quality_summary:
                        final_answer += f"\n\nüìä **Qualit√§tsbewertung:** {quality_summary}"
                
                # Sources formatieren
                sources_text = ""
                if sources:
                    sources_text = "\n\nÔøΩ **Quellen:**\n"
                    for i, source in enumerate(sources[:3], 1):  # Max 3 Quellen anzeigen
                        title = source.get('title', source.get('metadata', {}).get('title', f'Quelle {i}'))
                        sources_text += f"{i}. {title[:80]}...\n"
                
                # Status zur√ºcksetzen
                self.api_status_label.config(text="‚úÖ")
                self.status_var.set("Antwort erhalten")
                
                # Moderne Queue-basierte Response-Behandlung f√ºr Hauptfenster
                if hasattr(self, 'main_window') and self.main_window:
                    # Response-Daten f√ºr Queue-Message strukturieren
                    backend_response = {
                        'content': final_answer + sources_text,
                        'sources': sources,
                        'rag_metadata': response_data.get('rag_metadata', {}),
                        'citations_info': response_data.get('citations_info', {}),
                        'turn_id': response_data.get('turn_id'),
                        'confidence_score': confidence_score,
                        'quality_summary': quality_summary,
                        # ‚ú® NEU: Metadata f√ºr Raw-Response Debug-View
                        'metadata': {
                            'model': payload.get('model', 'unknown'),
                            'temperature': payload.get('temperature', 'N/A'),
                            'max_tokens': payload.get('max_tokens', 'N/A'),
                            'top_p': payload.get('top_p', 'N/A'),
                            'duration': response_data.get('rag_metadata', {}).get('duration', 'N/A'),
                            'raw_content': response_data.get('answer', final_answer)  # Ungefilterte LLM-Antwort
                        }
                    }
                    
                    # Queue-Message senden an Hauptfenster
                    queue_message = QueueMessage(
                        sender_id="API",
                        message_type="backend_response",
                        data=backend_response
                    )
                    
                    self.main_window.queue.put(queue_message)
                    logger.info(f"Backend-Response an Hauptfenster-Queue gesendet: {len(final_answer)} Zeichen")
                else:
                    # Fallback f√ºr alte Architektur
                    if self.root and hasattr(self.root, 'winfo_exists') and self.root.winfo_exists():
                        self.root.after(500, lambda: self.receive_api_response(final_answer + sources_text))
                
            else:
                # HTTP-Fehler behandeln
                logger.error(f"API HTTP-Fehler: {api_response.status_code}")
                try:
                    error_data = api_response.json()
                    error_msg = error_data.get("detail", f"HTTP {api_response.status_code}")
                except:
                    error_msg = f"API Fehler: HTTP {api_response.status_code}"
                
                self.api_status_label.config(text="‚ùå")
                self.add_error_message(f"API-Fehler: {error_msg}")
                
        except requests.exceptions.Timeout:
            logger.error("API-Timeout")
            self.api_status_label.config(text="‚è±Ô∏è")
            self.add_error_message("Timeout: API-Anfrage dauerte zu lange")
            
        except requests.exceptions.ConnectionError:
            logger.error("API-Verbindungsfehler")
            self.api_status_label.config(text="üîå")
            self.add_error_message("Verbindungsfehler: API-Server nicht erreichbar")
            
        except requests.exceptions.RequestException as e:
            logger.error(f"API-Netzwerkfehler: {e}")
            self.api_status_label.config(text="üåê")
            self.add_error_message(f"Netzwerkfehler: {e}")
            
        except Exception as e:
            logger.error(f"Unerwarteter API-Fehler: {e}")
            self.api_status_label.config(text="üí•")
            self.add_error_message(f"Unerwarteter Fehler: {e}")
    
    def receive_api_response(self, response, tag="assistant"):
        """Empf√§ngt API-Antwort mit Quality-Enhancement"""
        try:
            # Basis-Message erstellen
            assistant_message = {
                'role': 'assistant',
                'content': response,
                'timestamp': datetime.now().strftime('%H:%M:%S'),
                'tag': tag
            }
            
            # Quality Enhancement anwenden falls verf√ºgbar
            if self.quality_enabled and self.quality_formatter and isinstance(response, dict):
                try:
                    # Response ist bereits ein Dict von der API (mit Quality-Daten)
                    enhanced_response = self.quality_formatter.format_enhanced_response(response)
                    
                    # Enhanced Answer verwenden falls verf√ºgbar
                    if enhanced_response.get('enhanced_answer'):
                        assistant_message['content'] = enhanced_response['enhanced_answer']
                    
                    # Quality-Informationen hinzuf√ºgen
                    assistant_message.update({
                        'quality_info': enhanced_response.get('quality_summary', ''),
                        'enhanced_sources': enhanced_response.get('enhanced_sources', []),
                        'citations': enhanced_response.get('citations', []),
                        'display_suggestions': enhanced_response.get('display_suggestions', []),
                        'confidence_score': response.get('confidence_score', 0.0),
                        'processing_info': enhanced_response.get('processing_info', '')
                    })
                    
                    logger.info("‚úÖ Quality Enhancement f√ºr Response angewendet")
                    
                except Exception as quality_error:
                    logger.warning(f"Quality Enhancement fehlgeschlagen: {quality_error}")
                    # Fallback zu Standard-Response
            
            # Message zur History hinzuf√ºgen
            self.chat_messages.append(assistant_message)
            
            # ‚ú® NEU: Nachricht zur Chat-Session hinzuf√ºgen
            if hasattr(self, 'chat_session') and self.chat_session:
                content = assistant_message['content']
                if isinstance(content, dict):
                    content = content.get('answer', str(content))
                
                metadata = {
                    'tag': tag,
                    'confidence_score': assistant_message.get('confidence_score', 0.0),
                    'quality_info': assistant_message.get('quality_info', ''),
                    'sources': assistant_message.get('enhanced_sources', [])
                }
                
                self.chat_session.add_message(
                    role='assistant',
                    content=content,
                    metadata=metadata
                )
                
                # Auto-Save
                if hasattr(self, 'chat_persistence') and self.chat_persistence:
                    success = self.chat_persistence.save_chat_session(self.chat_session)
                    if success:
                        logger.debug(f"üíæ Chat-Session auto-saved: {self.chat_session.session_id[:8]}...")
            
            # Display updaten
            self.update_chat_display()
            self.update_message_count()
            self.api_status_label.config(text="üü¢")
            
            # Auto-Save (legacy)
            if self.auto_save_enabled:
                self.auto_save_chat()
                
        except Exception as e:
            logger.error(f"Fehler beim Verarbeiten der API-Response: {e}")
            self.add_error_message(f"Response-Verarbeitung fehlgeschlagen: {e}")
    
    def add_document(self):
        """F√ºgt Dokument hinzu"""
        filepath = filedialog.askopenfilename(
            title="Dokument ausw√§hlen",
            filetypes=[
                ("Alle unterst√ºtzten", "*.pdf;*.docx;*.txt;*.md"),
                ("PDF-Dateien", "*.pdf"),
                ("Word-Dateien", "*.docx"),
                ("Textdateien", "*.txt"),
                ("Markdown-Dateien", "*.md"),
                ("Alle Dateien", "*.*")
            ]
        )
        
        if filepath:
            doc_name = os.path.basename(filepath)
            current_text = self.input_text.get('1.0', tk.END).strip()
            
            if current_text:
                new_text = f"{current_text}\n\nüìé Angeh√§ngtes Dokument: {doc_name}"
            else:
                new_text = f"üìé Bitte analysiere das angeh√§ngte Dokument: {doc_name}"
            
            self.input_text.delete('1.0', tk.END)
            self.input_text.insert('1.0', new_text)
            
            self.add_system_message(f"üìé Dokument hinzugef√ºgt: {doc_name}")
            
            # UDS3 Integration - automatische Klassifizierung
            if self.is_uds3_available():
                self._auto_classify_document(filepath)
    
    def _auto_classify_document(self, filepath):
        """Automatische Dokumentklassifizierung mit UDS3"""
        try:
            # Datei-Inhalt lesen (vereinfacht)
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()[:1000]  # Erste 1000 Zeichen
            
            if self.security_manager:
                result = self.security_manager.classify_administrative_document(content, {
                    'filename': os.path.basename(filepath),
                    'filepath': filepath
                })
                
                self.add_system_message(
                    f"üîí Auto-Klassifizierung: {result.get('security_level', 'UNBEKANNT')} | "
                    f"{result.get('admin_classification', 'UNBEKANNT')}"
                )
        except Exception as e:
            logger.error(f"Auto-Klassifizierung fehlgeschlagen: {e}")
    
    def classify_document(self):
        """Klassifiziert aktuellen Text mit UDS3"""
        if not self.is_uds3_available():
            messagebox.showinfo("UDS3", "UDS3 v3.0 nicht verf√ºgbar")
            return
        
        text = self.input_text.get('1.0', tk.END).strip()
        if not text:
            messagebox.showinfo("Klassifizierung", "Bitte geben Sie Text ein")
            return
        
        # Modus auf classify setzen und Nachricht senden
        self.mode_var.set("classify")
        self.send_message()
    
    def assess_quality(self):
        """Bewertet Qualit√§t mit UDS3"""
        if not self.is_uds3_available():
            messagebox.showinfo("UDS3", "UDS3 v3.0 nicht verf√ºgbar")
            return
        
        text = self.input_text.get('1.0', tk.END).strip()
        if not text:
            messagebox.showinfo("Qualit√§tsbewertung", "Bitte geben Sie Text ein")
            return
        
        try:
            result = self.quality_manager.assess_content_quality(text, 'text')
            
            messagebox.showinfo("Qualit√§tsbewertung", 
                              f"Qualit√§tsstufe: {result.get('quality_level', 'UNBEKANNT')}\n"
                              f"Score: {result.get('score', 0):.2f}\n"
                              f"Details: {result.get('reasoning', 'Keine Details')}")
        except Exception as e:
            messagebox.showerror("Fehler", f"Qualit√§tsbewertung fehlgeschlagen:\n{e}")
    
    def batch_process(self):
        """√ñffnet Batch-Processing Dialog"""
        if not self.is_uds3_available():
            messagebox.showinfo("UDS3", "UDS3 v3.0 nicht verf√ºgbar")
            return
        
        messagebox.showinfo("Batch Processing", 
                          "Batch-Verarbeitung √ºber ThreadCoordinator-Pipeline\n"
                          "Diese Funktion wird in einem separaten Dialog implementiert.")
    
    def on_llm_change(self, event=None):
        """Behandelt LLM-√Ñnderung"""
        self.selected_llm = self.llm_var.get()
        self.add_system_message(f"ü§ñ LLM gewechselt zu: {self.selected_llm}")
    
    def on_mode_change(self, event=None):
        """Behandelt Modus-√Ñnderung"""
        selected_display = self.mode_var.get()
        
        # Finde den entsprechenden Modus in den geladenen Daten
        if hasattr(self, 'question_methods_data') and selected_display in self.question_methods_data:
            selected_method = self.question_methods_data[selected_display]
            mode_key = selected_method['key']
            description = selected_method['description']
            
            self.add_system_message(f"üîÑ Frage-Modus gewechselt zu: {selected_display}")
            if description:
                self.add_system_message(f"‚ÑπÔ∏è {description}")
                
            # Speichere aktuellen Modus f√ºr API-Anfragen
            self.current_question_mode = selected_method
            logger.info(f"Modus gewechselt zu: {mode_key} - {selected_display}")
        else:
            # Fallback f√ºr alte Modi
            mode_names = {
                'ask': 'Fragen',
                'agent': 'Agent-Modus', 
                'edit': 'Bearbeitung',
                'classify': 'UDS3 Klassifizierung'
            }
            self.add_system_message(f"üîÑ Modus gewechselt zu: {mode_names.get(selected_display, selected_display)}")
            self.current_question_mode = {'key': selected_display, 'endpoints': ['/ask']}
    
    def on_recent_chat_selected(self, event=None):
        """Behandelt Auswahl k√ºrzlicher Chat"""
        selected = self.recent_chats_var.get()
        if selected and selected != "K√ºrzliche Chats":
            if " - " in selected:
                filepath = selected.split(" - ")[-1]
                full_path = os.path.join(self.chats_dir, filepath)
                if os.path.exists(full_path):
                    self.load_chat_file(full_path)
            
            self.recent_chats_var.set("K√ºrzliche Chats")
    
    def update_recent_chats_dropdown(self):
        """Aktualisiert k√ºrzliche Chats Dropdown"""
        try:
            if not os.path.exists(self.chats_dir):
                return
            
            chat_files = []
            for filename in os.listdir(self.chats_dir):
                if filename.endswith('.json') and not filename.startswith('.'):
                    filepath = os.path.join(self.chats_dir, filename)
                    try:
                        title = self.get_chat_title_from_file(filepath) or "Unbenannt"
                        mtime = os.path.getmtime(filepath)
                        chat_files.append((title, filename, mtime))
                    except:
                        continue
            
            if chat_files:
                chat_files.sort(key=lambda x: x[2], reverse=True)
                
                dropdown_values = ["K√ºrzliche Chats"]
                for title, filename, _ in chat_files[:8]:
                    display_title = title if len(title) <= 20 else title[:17] + "..."
                    dropdown_values.append(f"{display_title} - {filename}")
                
                self.recent_chats_combo['values'] = dropdown_values
                
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren der k√ºrzlichen Chats: {e}")
    
    def get_chat_title_from_file(self, filepath):
        """Extrahiert Chat-Titel aus Datei"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return data.get('title', '')
        except:
            return ''
    
    def on_typing(self, event=None):
        """Behandelt Tippen-Events"""
        pass
    
    def toggle_auto_save(self):
        """Schaltet Auto-Speichern um"""
        self.auto_save_enabled = not self.auto_save_enabled
        status_text = "üíæ Auto-Speichern" if self.auto_save_enabled else "üíæ Aus"
        self.auto_save_label.config(text=status_text)
        
        message = "‚úÖ Auto-Speichern aktiviert" if self.auto_save_enabled else "‚ùå Auto-Speichern deaktiviert"
        self.add_system_message(message)
    
    def auto_save_chat(self):
        """Speichert Chat automatisch"""
        if self.auto_save_enabled and self.chat_messages:
            try:
                self.save_chat()
            except:
                pass
    
    def _load_backend_capabilities(self):
        """
        L√§dt Backend-Capabilities vom /capabilities Endpoint
        Erm√∂glicht dynamische Feature-Anpassung im Frontend
        """
        try:
            logger.info("üîç Lade Backend Capabilities...")
            response = requests.get(f"{API_BASE_URL}/capabilities", timeout=10)
            
            if response.status_code == 200:
                self.capabilities = response.json()
                
                # Log wichtige Informationen
                system_info = self.capabilities.get('system', {})
                features = self.capabilities.get('features', {})
                
                logger.info(f"‚úÖ Backend Capabilities geladen:")
                logger.info(f"   Version: {system_info.get('version', 'unknown')}")
                
                # Ollama Status
                ollama = features.get('ollama', {})
                if ollama.get('available'):
                    logger.info(f"   Ollama: {ollama.get('model_count', 0)} Modelle verf√ºgbar")
                
                return True
                
            else:
                logger.error(f"‚ùå Capabilities-Fehler: Status {response.status_code}")
                self.capabilities = {}
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Fehler bei Capabilities: {e}")
            self.capabilities = {}
            return False
    
    def is_feature_available(self, feature_path: str) -> bool:
        """
        Pr√ºft ob ein Feature verf√ºgbar ist
        
        Args:
            feature_path: Pfad im Capabilities-Dict, z.B. 'features.ollama.available'
        
        Returns:
            bool: True wenn Feature verf√ºgbar
        """
        parts = feature_path.split('.')
        current = self.capabilities
        
        for part in parts:
            if isinstance(current, dict) and part in current:
                current = current[part]
            else:
                return False
        
        return bool(current)
    
    def get_capability_value(self, path: str, default: Any = None) -> Any:
        """
        Holt einen Wert aus den Capabilities
        
        Args:
            path: Pfad im Capabilities-Dict, z.B. 'features.ollama.models'
            default: R√ºckgabewert wenn Pfad nicht existiert
        
        Returns:
            Der Wert am Pfad oder default
        """
        parts = path.split('.')
        current = self.capabilities
        
        for part in parts:
            if isinstance(current, dict) and part in current:
                current = current[part]
            else:
                return default
        
        return current

    
    def check_api_status(self):
        """Pr√ºft API-Status und erstellt Session"""
        try:
            # Lade Capabilities zuerst
            if not self.capabilities:
                self._load_backend_capabilities()
            
            # Versuche zuerst POST Health-Check
            health_data = {"level": "basic", "include_metrics": False}
            response = requests.post(f"{API_BASE_URL}/health", json=health_data, timeout=3)
            
            if response.status_code != 200:
                # Fallback auf GET
                response = requests.get(f"{API_BASE_URL}/health", timeout=5)
            
            if response.status_code == 200:
                self.connection_status.config(text="üü¢ Verbunden")
                self.api_connected = True
                
                # Session erstellen falls nicht vorhanden
                if not self.session_id:
                    if self._create_api_session():
                        self.status_var.set("API verbunden - Session erstellt")
                    else:
                        self.status_var.set("API verbunden - Session-Fehler")
                else:
                    self.status_var.set("API verbunden")
                
                # UDS3 Status hinzuf√ºgen
                if self.is_uds3_available():
                    current_status = self.status_var.get()
                    self.status_var.set(f"{current_status} | UDS3 v3.0")
                    
            else:
                self.connection_status.config(text="üî¥ Fehler")
                self.api_connected = False
                self.status_var.set("API-Fehler")
        except:
            self.connection_status.config(text="üî¥ Nicht verbunden")
            self.api_connected = False
            self.status_var.set("Nicht verbunden")
    
    def get_available_llm_models(self):
        """Ruft verf√ºgbare LLM-Modelle aus den Capabilities ab"""
        # Pr√ºfe zuerst Capabilities
        if self.capabilities:
            models = self.get_capability_value('features.ollama.models', [])
            if models:
                logger.info(f"‚úÖ {len(models)} LLM-Modelle aus Capabilities geladen")
                return models
        
        # Fallback: API-Call (f√ºr R√ºckw√§rtskompatibilit√§t)
        try:
            response = requests.get(f"{API_BASE_URL}/get_models", timeout=10)
            if response.status_code == 200:
                data = response.json()
                models_data = data.get('models', [])
                
                if models_data:
                    # Extrahiere Model-Namen aus der API-Response
                    model_names = []
                    for model in models_data:
                        model_name = model.get('name', 'unknown')
                        if model_name != 'unknown':
                            model_names.append(model_name)
                    
                    if model_names:
                        logger.info(f"‚úÖ {len(model_names)} LLM-Modelle vom API abgerufen")
                        return model_names
                    else:
                        logger.warning("‚ö†Ô∏è Alle Modelle haben 'unknown' Namen, verwende Fallback")
                        return ["llama3:latest", "mistral:latest", "codellama:latest"]
                else:
                    logger.warning("‚ö†Ô∏è Keine LLM-Modelle vom API erhalten")
                    return ["llama3:latest", "mistral:latest", "codellama:latest"]
            else:
                logger.error(f"‚ùå API-Fehler beim Abrufen der Modelle: Status {response.status_code}")
                return ["llama3:latest", "mistral:latest", "codellama:latest"]
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Verbindungsfehler beim Abrufen der LLM-Modelle: {e}")
            return ["llama3:latest", "mistral:latest", "codellama:latest"]
        except Exception as e:
            logger.error(f"‚ùå Unerwarteter Fehler beim Abrufen der LLM-Modelle: {e}")
            return ["llama3:latest", "mistral:latest", "codellama:latest"]
    
    def _create_api_session(self) -> bool:
        """Erstellt eine neue API-Session f√ºr ModernVeritasApp."""
        try:
            payload = {
                "user_id": f"veritas_modern_app_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            }
            
            response = requests.post(
                f"{API_BASE_URL}/start_session",
                json=payload,
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                self.session_id = data.get("session_id")
                logger.info(f"API-Session f√ºr ModernVeritasApp erstellt: {self.session_id}")
                return True
            else:
                logger.error(f"Session-Erstellung fehlgeschlagen: HTTP {response.status_code} - {response.text}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Netzwerkfehler bei Session-Erstellung: {e}")
            return False
        except Exception as e:
            logger.error(f"Fehler bei Session-Erstellung: {e}")
            return False
    
    def load_last_chat(self):
        """L√§dt letzten Chat"""
        try:
            if os.path.exists(self.last_chat_file):
                with open(self.last_chat_file, 'r', encoding='utf-8') as f:
                    filepath = f.read().strip()
                if filepath and os.path.exists(filepath):
                    self.load_chat_file(filepath)
        except:
            pass
    
    def update_chat_display(self):
        """Aktualisiert Chat-Anzeige mit Quality-Enhancement-Features"""
        self.chat_text.config(state='normal')
        self.chat_text.delete('1.0', tk.END)
        
        for msg in self.chat_messages:
            role = msg.get('role', 'unknown')
            content = msg.get('content', '')
            timestamp = msg.get('timestamp', '')
            tag = msg.get('tag', role)
            
            if role == 'system':
                self.chat_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
                self.chat_text.insert(tk.END, f"{content}\n\n", "system")
                
            elif role == 'user':
                self.chat_text.insert(tk.END, f"[{timestamp}] Sie:\n", "user")
                self.chat_text.insert(tk.END, f"{content}\n\n", "user")
                
            elif role == 'assistant':
                self.chat_text.insert(tk.END, f"[{timestamp}] Assistent:\n", tag)
                self.chat_text.insert(tk.END, f"{content}\n", tag)
                
                # Quality-Informationen anzeigen falls verf√ºgbar
                if self.quality_enabled and msg.get('quality_info'):
                    quality_info = msg.get('quality_info', '')
                    processing_info = msg.get('processing_info', '')
                    confidence_score = msg.get('confidence_score', 0.0)
                    
                    self.chat_text.insert(tk.END, "\nüìä Quality-Info:\n", "quality")
                    if quality_info:
                        self.chat_text.insert(tk.END, f"{quality_info}\n", "quality")
                    if processing_info:
                        self.chat_text.insert(tk.END, f"{processing_info}\n", "quality")
                    if confidence_score > 0:
                        self.chat_text.insert(tk.END, f"üéØ Vertrauen: {confidence_score:.1%}\n", "quality")
                
                # Enhanced Sources anzeigen
                enhanced_sources = msg.get('enhanced_sources', [])
                if enhanced_sources:
                    self.chat_text.insert(tk.END, "\nüìö Quellen:\n", "sources")
                    for i, source in enumerate(enhanced_sources[:3], 1):  # Max 3 Quellen anzeigen
                        quality_indicator = source.get('quality_indicator', 'üìÑ')
                        title = source.get('title', f'Quelle {i}')
                        quality_level = source.get('quality_level', '')
                        
                        source_text = f"{quality_indicator} {title}"
                        if quality_level:
                            source_text += f" ({quality_level})"
                        
                        self.chat_text.insert(tk.END, f"   {source_text}\n", "sources")
                
                # Display-Suggestions anzeigen
                suggestions = msg.get('display_suggestions', [])
                if suggestions:
                    self.chat_text.insert(tk.END, "\nüí° Verbesserungsvorschl√§ge:\n", "suggestions")
                    for suggestion in suggestions[:2]:  # Max 2 Suggestions
                        self.chat_text.insert(tk.END, f"   ‚Ä¢ {suggestion}\n", "suggestions")
                
                self.chat_text.insert(tk.END, "\n", "assistant")
                
            elif role == 'error':
                self.chat_text.insert(tk.END, f"[{timestamp}] Fehler:\n", "error")
                self.chat_text.insert(tk.END, f"{content}\n\n", "error")
        
        self.chat_text.config(state='disabled')
        self.chat_text.see(tk.END)
    
    def update_title(self, title):
        """Aktualisiert Fenstertitel"""
        self.root.title(f"üí¨ {title} - Veritas Chat")
    
    def update_message_count(self):
        """Aktualisiert Nachrichten-Z√§hler"""
        count = len([msg for msg in self.chat_messages if msg.get('role') in ['user', 'assistant']])
        self.message_count_label.config(text=str(count))
    
    def add_system_message(self, message):
        """F√ºgt System-Nachricht hinzu"""
        system_msg = {
            'role': 'system',
            'content': message,
            'timestamp': datetime.now().strftime('%H:%M:%S')
        }
        self.chat_messages.append(system_msg)
        self.update_chat_display()
    
    def add_error_message(self, message):
        """F√ºgt Fehler-Nachricht hinzu"""
        error_msg = {
            'role': 'error',
            'content': message,
            'timestamp': datetime.now().strftime('%H:%M:%S')
        }
        self.chat_messages.append(error_msg)
        self.update_chat_display()
    
    def _load_last_conversation_gui(self):
        """L√§dt automatisch die letzte Conversation f√ºr die GUI"""
        try:
            # Verwende gleiche Logik wie MainChatWindow
            recent_chats = self._get_recent_chats_gui()
            if recent_chats:
                latest_chat = recent_chats[0]  # Neueste Chat
                chat_path = latest_chat['path']
                chat_name = latest_chat['name']
                
                # Pr√ºfe Alter der Datei
                import time
                age_days = (time.time() - latest_chat['mtime']) / (24 * 60 * 60)
                
                if age_days <= 7:  # Nur Chats der letzten Woche
                    try:
                        with open(chat_path, 'r', encoding='utf-8') as f:
                            chat_messages = json.load(f)
                        
                        if isinstance(chat_messages, list) and len(chat_messages) > 0:
                            self.chat_messages = chat_messages
                            self._conversation_loaded = True
                            
                            # Status-Update
                            import os
                            filename = os.path.basename(chat_path)
                            self.status_var.set(f"Letzte Conversation geladen: {filename}")
                            logger.info(f"Letzte Conversation automatisch geladen: {chat_name}")
                            
                            # Session-ID extrahieren
                            for msg in chat_messages:
                                if isinstance(msg, dict) and msg.get('session_id'):
                                    self.session_id = msg['session_id']
                                    break
                            
                            # Chat-Display aktualisieren
                            self.update_chat_display()
                            return True
                            
                    except Exception as e:
                        logger.warning(f"Fehler beim Laden der GUI-Conversation: {e}")
                        
        except Exception as e:
            logger.debug(f"Keine GUI-Conversation-Wiederherstellung m√∂glich: {e}")
        
        return False
    
    def _get_recent_chats_gui(self):
        """GUI-Version von _get_recent_chats"""
        try:
            import glob
            import os
            from pathlib import Path
            
            # Erweiterte Suchpfade f√ºr GUI
            search_paths = [
                os.path.expanduser("~/Documents/*.json"),
                os.path.expanduser("~/Desktop/*.json"), 
                os.path.join(os.getcwd(), "*.json"),
                os.path.join(os.getcwd(), "chats", "*.json"),
                os.path.join(os.getcwd(), "conversations", "*.json"),
            ]
            
            chat_files = []
            for pattern in search_paths:
                chat_files.extend(glob.glob(pattern))
            
            unique_files = list(set(chat_files))
            recent_chats = []
            
            for file_path in unique_files:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    
                    if isinstance(data, list) and len(data) > 0:
                        first_item = data[0]
                        if isinstance(first_item, dict) and 'role' in first_item and 'content' in first_item:
                            chat_name = Path(file_path).stem
                            
                            for msg in data:
                                if msg.get('role') == 'user':
                                    content = msg.get('content', '').strip()
                                    if content:
                                        chat_name = content[:50] + ("..." if len(content) > 50 else "")
                                        break
                            
                            recent_chats.append({
                                'name': chat_name,
                                'path': file_path,
                                'mtime': os.path.getmtime(file_path)
                            })
                except:
                    continue
            
            recent_chats.sort(key=lambda x: x['mtime'], reverse=True)
            return recent_chats
            
        except Exception as e:
            logger.debug(f"Fehler bei _get_recent_chats_gui: {e}")
            return []
    
    def open_settings(self):
        """√ñffnet Einstellungen"""
        messagebox.showinfo("Einstellungen", "Einstellungen-Dialog wird implementiert")
    
    def show_about(self):
        """Zeigt √úber-Dialog mit UDS3 und Quality-Enhancement Status"""
        uds3_info = ""
        if self.is_uds3_available():
            uds3_info = "\n\nüî• UDS3 v3.0 Core Features:\n" \
                       "‚Ä¢ OptimizedUnifiedDatabaseStrategy\n" \
                       "‚Ä¢ Administrative Dokument-Klassifizierung\n" \
                       "‚Ä¢ Security Level Management\n" \
                       "‚Ä¢ Quality Assessment & Batch Processing"
        else:
            uds3_info = "\n\n‚öôÔ∏è Standard-Modus (UDS3 v3.0 nicht verf√ºgbar)"
        
        quality_info = ""
        if self.quality_enabled and self.quality_formatter:
            quality_info = "\n\n‚ö° Quality-Enhanced RAG Features:\n" \
                          "‚Ä¢ Quality-aware Chunk Ranking\n" \
                          "‚Ä¢ Confidence Scoring\n" \
                          "‚Ä¢ Source Quality Indicators\n" \
                          "‚Ä¢ Enhanced Citations\n" \
                          "‚Ä¢ Multiple Relevance Strategies"
        elif hasattr(self, 'quality_formatter'):
            quality_info = "\n\n‚ùå Quality-Enhancement (deaktiviert)"
        else:
            quality_info = "\n\n‚ö†Ô∏è Quality-Enhancement (nicht verf√ºgbar)"
        
        about_text = f"""Veritas Modern Chat GUI v{__version__}

Ein modernes Chat-Interface f√ºr das Veritas RAG System mit UDS3 v3.0 und Quality-Enhancement Integration.

Features:
‚Ä¢ Einheitliches modernes Design
‚Ä¢ Kompakte Chat-Steuerung
‚Ä¢ Auto-Speicher-Funktion
‚Ä¢ Mehrere LLM-Modelle
‚Ä¢ Dokument-Integration
‚Ä¢ Queue-basierte Thread-Kommunikation{uds3_info}{quality_info}"""

        messagebox.showinfo("√úber Veritas", about_text)
    
    def open_immi_map(self):
        """√ñffnet IMMI-Karte in separatem Fenster"""
        try:
            # Import des Map-Widgets
            from frontend.ui.veritas_ui_map_widget import IMMIMapWidget
            
            # Neues Fenster erstellen
            map_window = tk.Toplevel(self.root)
            map_window.title("üó∫Ô∏è IMMI-Karte - BImSchG & WKA Geodaten")
            map_window.geometry("1400x800")
            
            # Backend-URL ermitteln (Standard localhost:5000)
            backend_url = "http://localhost:5000"
            
            # Map-Widget erstellen
            map_widget = IMMIMapWidget(map_window, backend_url=backend_url)
            map_widget.pack(fill="both", expand=True)
            
            logger.info("‚úÖ IMMI-Karte ge√∂ffnet")
            
        except ImportError as e:
            logger.error(f"‚ùå Map-Widget nicht gefunden: {e}")
            messagebox.showerror(
                "Fehler",
                "IMMI-Karte konnte nicht geladen werden.\n\n"
                "Fehlende Module:\n"
                "- tkintermapview\n"
                "- veritas_ui_map_widget\n\n"
                "Installieren Sie: pip install tkintermapview"
            )
        except Exception as e:
            logger.error(f"‚ùå Fehler beim √ñffnen der IMMI-Karte: {e}")
            messagebox.showerror("Fehler", f"IMMI-Karte konnte nicht ge√∂ffnet werden:\n\n{e}")
    
    def show_help(self):
        """Zeigt Hilfe"""
        help_text = """Veritas Chat - Hilfe

Tastatur-Shortcuts:
‚Ä¢ Strg+N: Neuer Chat
‚Ä¢ Strg+O: Chat √∂ffnen
‚Ä¢ Strg+S: Chat speichern
‚Ä¢ Strg+Enter: Nachricht senden
‚Ä¢ F5: API-Status aktualisieren

Verwendung:
‚Ä¢ Tippen Sie Ihre Nachricht in das Eingabefeld
‚Ä¢ W√§hlen Sie ein LLM-Modell und einen Modus aus
‚Ä¢ F√ºgen Sie Dokumente mit dem üìé-Button hinzu
‚Ä¢ Verwenden Sie das ‚ò∞-Men√º f√ºr weitere Optionen

UDS3 v3.0 Features:
‚Ä¢ üîí Klassifizieren: Sicherheits- und Qualit√§tsbewertung
‚Ä¢ üìä Automatische Dokumentklassifizierung
‚Ä¢ üî• Optimierte Datenbank-Operationen"""

        messagebox.showinfo("Hilfe", help_text)
    
    def on_closing(self):
        """Behandelt Schlie√üen der Anwendung"""
        if self.auto_save_enabled and self.chat_messages:
            try:
                self.save_chat()
            except:
                pass
        
        # Letzten Chat speichern
        if self.current_chat_file:
            try:
                with open(self.last_chat_file, 'w', encoding='utf-8') as f:
                    f.write(self.current_chat_file)
            except:
                pass
        
        self.root.destroy()
    
    # --- Backend Communication Methods ---
    # Frontend kommuniziert ausschlie√ülich √ºber HTTP/HTTPS mit dem Backend
    # Keine direkten Datenbankzugriffe oder UDS3-Abh√§ngigkeiten
    
    def is_uds3_available(self):
        """UDS3 ist im Frontend nicht verf√ºgbar - Backend entscheidet √ºber Datenbankzugriffe"""
        return False
    
    def get_uds3_strategy(self):
        """Keine UDS3 Strategy im Frontend - Backend verwaltet alle Datenbankoperationen"""
        return None
    
    def get_security_manager(self):
        """Gibt Security Manager zur√ºck"""
        return getattr(self, 'security_manager', None)
    
    def get_quality_manager(self):
        """Gibt Quality Manager zur√ºck"""
        return getattr(self, 'quality_manager', None)
    
    def toggle_quality_enhancement(self):
        """Schaltet Quality-Enhancement um"""
        if hasattr(self, 'quality_formatter') and self.quality_formatter:
            self.quality_enabled = not self.quality_enabled
            
            # Status-Label updaten
            if hasattr(self, 'quality_status_label'):
                if self.quality_enabled:
                    self.quality_status_label.config(
                        text="‚ö° Quality-Enhanced",
                        foreground=self.colors['success']
                    )
                else:
                    self.quality_status_label.config(
                        text="‚ö° Quality (Off)",
                        foreground=self.colors['secondary']
                    )
            
            # Status-Nachricht
            status_msg = "aktiviert" if self.quality_enabled else "deaktiviert"
            self.add_system_message(f"‚ö° Quality-Enhancement {status_msg}")
            
            logger.info(f"Quality-Enhancement {'aktiviert' if self.quality_enabled else 'deaktiviert'}")
        else:
            self.add_error_message("Quality-Enhancement nicht verf√ºgbar")
    
    def toggle_auto_save(self):
        """Schaltet Auto-Speichern um"""
        self.auto_save_enabled = not self.auto_save_enabled
        status_msg = "aktiviert" if self.auto_save_enabled else "deaktiviert"
        self.add_system_message(f"üíæ Auto-Speichern {status_msg}")
    
    def run(self):
        """Startet die GUI"""
        # Versuche letzte Conversation zu laden
        self._load_last_conversation_gui()
        
        # Willkommensnachricht (nur wenn keine Conversation geladen wurde)
        if not hasattr(self, '_conversation_loaded') or not self._conversation_loaded:
            welcome_msg = "üåü Veritas Modern Chat GUI gestartet"
            if self.is_uds3_available():
                welcome_msg += " mit UDS3 v3.0 Core"
            welcome_msg += " - Bereit f√ºr Gespr√§che!"
            
            self.add_system_message(welcome_msg)
        
        # API-Status pr√ºfen (alle 30 Sekunden statt jede Sekunde)
        if self.root and hasattr(self.root, 'winfo_exists') and self.root.winfo_exists():
            self.root.after(30000, self.check_api_status)
        
        # GUI starten
        self.root.mainloop()

# === HAUPTAUSF√úHRUNG MIT OOP-ARCHITEKTUR ===

def main():
    """Hauptfunktion mit OOP-basierter Multi-Window-Architektur"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Veritas App - OOP Multi-Window-Chat mit UDS3 v3.0")
    parser.add_argument('--verbose', action='store_true', help='Debug-Logging aktivieren')
    parser.add_argument('--version', action='store_true', help='Versionsinformation anzeigen')
    parser.add_argument('--help-architecture', action='store_true', help='Architektur-Information anzeigen')
    args = parser.parse_args()
    
    if args.version:
        print(f"Veritas App v{__version__}")
        print("OOP Multi-Window-Chat mit Queue-basierter Thread-Kommunikation")
        print(f"Core Engine: {'‚úÖ Verf√ºgbar' if CORE_AVAILABLE else '‚ùå Nicht verf√ºgbar'}")
        return
    
    if args.help_architecture:
        print(f"Veritas App v{__version__} - Architektur-√úbersicht")
        print("=" * 60)
        print("üèóÔ∏è OOP-ARCHITEKTUR:")
        print("  ‚Ä¢ ThreadManager: Verwaltet alle Chat-Threads")
        print("  ‚Ä¢ QueueMessage: Typisierte Nachrichten-System")
        print("  ‚Ä¢ ChatWindowBase: Abstrakte Basis f√ºr alle Fenster")
        print("  ‚Ä¢ MainChatWindow: Hauptfenster (Main-Thread)")
        print("  ‚Ä¢ ChildChatWindow: Child-Fenster (eigene Threads)")
        print("  ‚Ä¢ VeritasApp: Koordiniert das Multi-Window-Management")
        print("")
        print("üîÑ THREAD-MANAGEMENT:")
        print("  ‚Ä¢ Main-Thread: GUI und Hauptfenster")
        print("  ‚Ä¢ Child-Threads: Separate Message-Loops pro Fenster")
        print("  ‚Ä¢ Queue-Communication: Thread-safe Nachrichten-Austausch")
        print("  ‚Ä¢ Graceful-Shutdown: Sauberes Beenden aller Threads")
        print("")
        print("üí¨ WINDOW-MANAGEMENT:")
        print("  ‚Ä¢ Erstes Fenster = Hauptfenster")
        print("  ‚Ä¢ Weitere Fenster = Child-Fenster")
        print("  ‚Ä¢ Chat-Transfer beim Schlie√üen m√∂glich")
        print("  ‚Ä¢ Hauptfenster √ºbernimmt Child-Inhalt vor dem Beenden")
        return
    
    # Logging konfigurieren
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(levelname)s [%(name)s] - %(message)s',
        handlers=[
            logging.FileHandler('veritas_app.log', encoding='utf-8'),
            logging.StreamHandler()
        ]
    )
    
    logger.info("=" * 60)
    logger.info(f"üöÄ STARTE VERITAS APP v{__version__}")
    logger.info("=" * 60)
    logger.info(f"üåê Backend-API: {API_BASE_URL}")
    logger.info(f"üèóÔ∏è OOP-Architektur: Multi-Window mit Queue-Threading")
    logger.info("=" * 60)
    
    try:
        # Neue OOP-basierte App starten
        app = VeritasApp()
        app.run()
        
    except KeyboardInterrupt:
        logger.info("üëã Anwendung durch Benutzer beendet")
    except Exception as e:
        logger.critical(f"üí• Kritischer Fehler: {e}")
        messagebox.showerror("Startfehler", f"Anwendung konnte nicht gestartet werden:\n{e}")
    
    logger.info("üèÅ Veritas App beendet")

# Test und Hauptausf√ºhrung
if __name__ == "__main__":
    main()

"""
VERITAS Protected Module
WARNING: This file contains embedded protection keys. 
Modification will be detected and may result in license violations.
"""

# === VERITAS PROTECTION KEYS (DO NOT MODIFY) ===
module_name = "veritas_app"
module_licenced_organization = "VERITAS_TECH_GMBH"
module_licence_key = "eyJjbGllbnRfaWQi...NzRkYzhl"  # Gekuerzt fuer Sicherheit
module_organization_key = "6f5304c29594443086e1ace0011c094614b612c22aa16af9f1a63f02a0c9bf5c"
module_file_key = "c73bb1f484ccf652d08fd04474db173ec3702cecb211b1bb9ceebe55ea66bad0"
module_version = "1.0"
module_protection_level = 2
# === END PROTECTION KEYS ===
