"""
UDS3 Vector Backend Setup
Konfiguriert ChromaDB und indexiert Demo-Corpus f√ºr Phase 5 Hybrid Search
"""
import asyncio
import sys
from pathlib import Path
import time

# Add project root
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Demo Corpus (same as BM25 demo)
DEMO_CORPUS = [
    {
        "doc_id": "bgb_110",
        "title": "¬ß 110 BGB - Taschengeldparagraph",
        "content": "¬ß 110 BGB - Bewirken der Leistung mit eigenen Mitteln. Ein von dem Minderj√§hrigen ohne Zustimmung des gesetzlichen Vertreters geschlossener Vertrag gilt als von Anfang an wirksam, wenn der Minderj√§hrige die vertragsm√§√üige Leistung mit Mitteln bewirkt, die ihm zu diesem Zweck oder zu freier Verf√ºgung von dem Vertreter oder mit dessen Zustimmung von einem Dritten √ºberlassen worden sind. Praktische Bedeutung: Der sogenannte Taschengeldparagraph erlaubt es Minderj√§hrigen, Vertr√§ge mit ihrem Taschengeld wirksam abzuschlie√üen, ohne dass die Eltern zustimmen m√ºssen.",
        "metadata": {"source": "BGB", "paragraph": "110", "category": "Legal", "topic": "Vertragsrecht"}
    },
    {
        "doc_id": "bgb_433",
        "title": "¬ß 433 BGB - Vertragstypische Pflichten beim Kaufvertrag",
        "content": "¬ß 433 BGB - Vertragstypische Pflichten beim Kaufvertrag. Durch den Kaufvertrag wird der Verk√§ufer einer Sache verpflichtet, dem K√§ufer die Sache zu √ºbergeben und das Eigentum an der Sache zu verschaffen. Der Verk√§ufer hat dem K√§ufer die Sache frei von Sach- und Rechtsm√§ngeln zu verschaffen. Der K√§ufer ist verpflichtet, dem Verk√§ufer den vereinbarten Kaufpreis zu zahlen und die gekaufte Sache abzunehmen. Grundnorm des Kaufvertragsrechts.",
        "metadata": {"source": "BGB", "paragraph": "433", "category": "Legal", "topic": "Kaufrecht"}
    },
    {
        "doc_id": "vwvfg_24",
        "title": "¬ß 24 VwVfG - Anh√∂rung Beteiligter",
        "content": "¬ß 24 VwVfG - Anh√∂rung Beteiligter. Bevor ein Verwaltungsakt erlassen wird, der in Rechte eines Beteiligten eingreift, ist diesem Gelegenheit zu geben, sich zu den f√ºr die Entscheidung erheblichen Tatsachen zu √§u√üern. Von der Anh√∂rung kann abgesehen werden bei Gefahr im Verzug oder im √∂ffentlichen Interesse. Rechtliches Geh√∂r ist ein Grundprinzip des Verwaltungsverfahrens.",
        "metadata": {"source": "VwVfG", "paragraph": "24", "category": "Administrative", "topic": "Verwaltungsverfahren"}
    },
    {
        "doc_id": "vwvfg_35",
        "title": "¬ß 35 VwVfG - Begriff des Verwaltungsakts",
        "content": "¬ß 35 VwVfG - Begriff des Verwaltungsakts. Verwaltungsakt ist jede Verf√ºgung, Entscheidung oder andere hoheitliche Ma√ünahme, die eine Beh√∂rde zur Regelung eines Einzelfalls auf dem Gebiet des √∂ffentlichen Rechts trifft und die auf unmittelbare Rechtswirkung nach au√üen gerichtet ist. Allgemeinverf√ºgung ist ein Verwaltungsakt, der sich an einen nach allgemeinen Merkmalen bestimmten oder bestimmbaren Personenkreis richtet. Zentrale Definition f√ºr Verwaltungsrecht.",
        "metadata": {"source": "VwVfG", "paragraph": "35", "category": "Administrative", "topic": "Verwaltungsrecht"}
    },
    {
        "doc_id": "uwg_3",
        "title": "¬ß 3 UWG - Verbot unlauterer gesch√§ftlicher Handlungen",
        "content": "¬ß 3 UWG - Verbot unlauterer gesch√§ftlicher Handlungen. Unlautere gesch√§ftliche Handlungen sind unzul√§ssig. Gesch√§ftliche Handlungen, die sich an Verbraucher richten oder diese erreichen, sind unlauter, wenn sie nicht der unternehmerischen Sorgfalt entsprechen und dazu geeignet sind, das wirtschaftliche Verhalten des Verbrauchers wesentlich zu beeinflussen. Verbraucherschutz im Wettbewerbsrecht.",
        "metadata": {"source": "UWG", "paragraph": "3", "category": "Legal", "topic": "Wettbewerbsrecht"}
    },
    {
        "doc_id": "umwelt_45",
        "title": "¬ß 45 Umweltgesetz - Emissionsschutz",
        "content": "¬ß 45 Umweltgesetz - Emissionsschutz und Grenzwerte. Genehmigungsbed√ºrftige Anlagen sind so zu errichten und zu betreiben, dass zur Gew√§hrleistung eines hohen Schutzniveaus f√ºr die Umwelt insgesamt sch√§dliche Umwelteinwirkungen nicht hervorgerufen werden k√∂nnen. Die Pflichten sind zu erf√ºllen durch die dem Stand der Technik entsprechende Emissionsbegrenzung. Best-Available-Technology Prinzip f√ºr Umweltschutz.",
        "metadata": {"source": "Umweltgesetz", "paragraph": "45", "category": "Environmental", "topic": "Umweltschutz"}
    },
    {
        "doc_id": "stgb_242",
        "title": "¬ß 242 StGB - Diebstahl",
        "content": "¬ß 242 StGB - Diebstahl. Wer eine fremde bewegliche Sache einem anderen in der Absicht wegnimmt, die Sache sich oder einem Dritten rechtswidrig zuzueignen, wird mit Freiheitsstrafe bis zu f√ºnf Jahren oder mit Geldstrafe bestraft. Der Versuch ist strafbar. Grunddelikt des Eigentumsstrafrechts. Tatbestandsmerkmale: fremd, beweglich, wegnehmen, Zueignungsabsicht.",
        "metadata": {"source": "StGB", "paragraph": "242", "category": "Legal", "topic": "Strafrecht"}
    },
    {
        "doc_id": "gg_1",
        "title": "Art. 1 GG - Menschenw√ºrde",
        "content": "Art. 1 GG - Menschenw√ºrde. Die W√ºrde des Menschen ist unantastbar. Sie zu achten und zu sch√ºtzen ist Verpflichtung aller staatlichen Gewalt. Das Deutsche Volk bekennt sich darum zu unverletzlichen und unver√§u√üerlichen Menschenrechten als Grundlage jeder menschlichen Gemeinschaft, des Friedens und der Gerechtigkeit in der Welt. H√∂chster Wert der deutschen Verfassung, Kern aller Grundrechte.",
        "metadata": {"source": "GG", "paragraph": "1", "category": "Constitutional", "topic": "Grundrechte"}
    }
]

async def setup_vector_backend():
    """Setup UDS3 Vector Backend mit ChromaDB und Embeddings"""
    print("=" * 80)
    print("UDS3 VECTOR BACKEND SETUP")
    print("=" * 80)
    print()
    
    try:
        # Step 1: Check UDS3
        print("üìä SCHRITT 1: UDS3 System Check")
        print("-" * 80)
        
        from uds3.uds3_core import get_optimized_unified_strategy
        
        print("üîÑ Initialisiere UDS3...")
        uds3 = get_optimized_unified_strategy()
        print(f"‚úÖ UDS3 Strategy: {uds3.__class__.__name__}")
        print()
        
        # Step 2: Check Vector Backend
        print("üìä SCHRITT 2: Vector Backend Check")
        print("-" * 80)
        
        has_vector_backend = False
        collection = None
        
        # Try different approaches to access vector backend
        if hasattr(uds3, 'vector_backend'):
            print("‚úÖ vector_backend Attribut gefunden")
            vector_backend = uds3.vector_backend
            
            if hasattr(vector_backend, 'collection'):
                collection = vector_backend.collection
                print(f"‚úÖ ChromaDB Collection: {collection}")
                has_vector_backend = True
            else:
                print("‚ö†Ô∏è vector_backend hat keine collection")
        else:
            print("‚ö†Ô∏è UDS3 hat kein vector_backend Attribut")
            
            # Try to find collection via other paths
            for attr in dir(uds3):
                if not attr.startswith('_'):
                    obj = getattr(uds3, attr, None)
                    if obj and hasattr(obj, 'collection'):
                        print(f"   üîç Gefunden: {attr}.collection")
                        collection = obj.collection
                        has_vector_backend = True
                        break
        
        print()
        
        if not has_vector_backend or not collection:
            print("‚ùå PROBLEM: ChromaDB Collection nicht gefunden!")
            print()
            print("L√ñSUNGSOPTIONEN:")
            print("1. ChromaDB manuell initialisieren")
            print("2. UDS3 Config √ºberpr√ºfen")
            print("3. Alternative: Mock Vector Search verwenden")
            print()
            
            # Try to initialize ChromaDB directly
            print("üîÑ Versuche ChromaDB direkt zu initialisieren...")
            try:
                import chromadb
                
                chroma_client = chromadb.Client()
                collection = chroma_client.get_or_create_collection(
                    name="veritas_demo",
                    metadata={"hnsw:space": "cosine"}
                )
                print(f"‚úÖ ChromaDB Collection erstellt: {collection.name}")
                print(f"   Items: {collection.count()}")
                has_vector_backend = True
            except Exception as e:
                print(f"‚ùå ChromaDB Fehler: {e}")
                return False
        
        print()
        
        # Step 3: Check Ollama for Embeddings
        print("üìä SCHRITT 3: Ollama Embedding Check")
        print("-" * 80)
        
        ollama_available = False
        embedding_model = None
        
        try:
            import requests
            
            # Check Ollama is running
            response = requests.get("http://localhost:11434/api/tags", timeout=2)
            
            if response.status_code == 200:
                models = response.json().get('models', [])
                print(f"‚úÖ Ollama l√§uft - {len(models)} Modelle verf√ºgbar")
                
                # Check for embedding models
                embedding_models = [m for m in models if 'embed' in m.get('name', '').lower() or m.get('name') in ['nomic-embed-text', 'mxbai-embed-large', 'all-minilm']]
                
                if embedding_models:
                    embedding_model = embedding_models[0]['name']
                    print(f"‚úÖ Embedding-Modell gefunden: {embedding_model}")
                    ollama_available = True
                else:
                    # Use any available model for embeddings
                    if models:
                        embedding_model = models[0]['name']
                        print(f"‚ö†Ô∏è Kein dediziertes Embedding-Modell, nutze: {embedding_model}")
                        ollama_available = True
                    else:
                        print("‚ö†Ô∏è Keine Modelle verf√ºgbar")
            else:
                print(f"‚ö†Ô∏è Ollama Response: {response.status_code}")
                
        except requests.exceptions.ConnectionError:
            print("‚ùå Ollama nicht erreichbar (http://localhost:11434)")
            print("   Start: ollama serve")
        except Exception as e:
            print(f"‚ùå Ollama Check Fehler: {e}")
        
        print()
        
        if not ollama_available:
            print("‚ö†Ô∏è OHNE OLLAMA: Verwende ChromaDB Default-Embeddings")
            print("   ChromaDB nutzt sentence-transformers als Fallback")
            embedding_model = "chroma_default"
        
        print()
        
        # Step 4: Index Demo Corpus
        print("üìä SCHRITT 4: Demo-Corpus Indexierung")
        print("-" * 80)
        print(f"Corpus: {len(DEMO_CORPUS)} Dokumente")
        print()
        
        if not collection:
            print("‚ùå Keine Collection verf√ºgbar - Abbruch")
            return False
        
        # Check current count
        current_count = collection.count()
        print(f"üìÑ Aktuelle Collection-Gr√∂√üe: {current_count}")
        
        if current_count >= len(DEMO_CORPUS):
            print("‚ö†Ô∏è Collection enth√§lt bereits Dokumente")
            print("   Optionen:")
            print("   A) √úberspringen")
            print("   B) Neu indexieren (l√∂scht alte Daten)")
            print()
            # For automation, skip if already indexed
            print("üîÑ Auto-Entscheidung: √úberspringen (bereits indexiert)")
        else:
            print("üîÑ Indexiere Dokumente...")
            print()
            
            # Prepare data
            ids = [doc['doc_id'] for doc in DEMO_CORPUS]
            documents = [doc['content'] for doc in DEMO_CORPUS]
            metadatas = [
                {
                    "doc_id": doc['doc_id'],
                    "title": doc['title'],
                    **doc['metadata']
                }
                for doc in DEMO_CORPUS
            ]
            
            # Generate embeddings and add to collection
            if ollama_available and embedding_model != "chroma_default":
                print(f"   üîÑ Generiere Embeddings mit Ollama ({embedding_model})...")
                
                # Generate embeddings via Ollama
                embeddings = []
                for i, doc in enumerate(DEMO_CORPUS, 1):
                    try:
                        print(f"   [{i}/{len(DEMO_CORPUS)}] {doc['doc_id']}... ", end="", flush=True)
                        
                        response = requests.post(
                            "http://localhost:11434/api/embeddings",
                            json={
                                "model": embedding_model,
                                "prompt": doc['content']
                            },
                            timeout=10
                        )
                        
                        if response.status_code == 200:
                            embedding = response.json().get('embedding', [])
                            embeddings.append(embedding)
                            print("‚úÖ")
                        else:
                            print(f"‚ùå Status {response.status_code}")
                            return False
                            
                    except Exception as e:
                        print(f"‚ùå Error: {e}")
                        return False
                
                print()
                print(f"   ‚úÖ {len(embeddings)} Embeddings generiert")
                print(f"   üîÑ F√ºge zu ChromaDB hinzu...")
                
                # Add with embeddings
                collection.add(
                    ids=ids,
                    embeddings=embeddings,
                    documents=documents,
                    metadatas=metadatas
                )
            else:
                print(f"   üîÑ Nutze ChromaDB Default-Embeddings...")
                
                # Let ChromaDB generate embeddings
                collection.add(
                    ids=ids,
                    documents=documents,
                    metadatas=metadatas
                )
            
            print(f"   ‚úÖ Indexierung abgeschlossen!")
        
        print()
        
        # Step 5: Verify with Test Query
        print("üìä SCHRITT 5: Vector Search Test")
        print("-" * 80)
        
        test_query = "BGB Vertragsrecht Minderj√§hrige"
        print(f"Query: \"{test_query}\"")
        print()
        
        # Query collection
        print("üîÑ F√ºhre Vector Search aus...")
        
        if ollama_available and embedding_model != "chroma_default":
            # Generate query embedding via Ollama
            print(f"   üîÑ Generiere Query-Embedding ({embedding_model})...")
            response = requests.post(
                "http://localhost:11434/api/embeddings",
                json={
                    "model": embedding_model,
                    "prompt": test_query
                },
                timeout=10
            )
            
            if response.status_code == 200:
                query_embedding = response.json().get('embedding', [])
                print(f"   ‚úÖ Query-Embedding: {len(query_embedding)} dimensions")
                
                results = collection.query(
                    query_embeddings=[query_embedding],
                    n_results=3
                )
            else:
                print(f"   ‚ùå Embedding-Fehler: {response.status_code}")
                return False
        else:
            # ChromaDB generates query embedding
            results = collection.query(
                query_texts=[test_query],
                n_results=3
            )
        
        print()
        print("üìÑ Top Results:")
        
        if results and results.get('ids') and results['ids'][0]:
            for i, (doc_id, distance, doc) in enumerate(zip(
                results['ids'][0],
                results['distances'][0],
                results['documents'][0]
            ), 1):
                score = 1 / (1 + distance)  # Convert distance to similarity score
                print(f"   {i}. {doc_id} (Score: {score:.3f}, Distance: {distance:.3f})")
                print(f"      {doc[:100]}...")
            
            print()
            print("‚úÖ Vector Search funktioniert!")
            
            # Check if expected doc is top-1
            if results['ids'][0][0] == "bgb_110":
                print("‚úÖ EXPECTED DOC in Top-1: bgb_110")
            else:
                print(f"‚ö†Ô∏è Expected bgb_110, got {results['ids'][0][0]}")
        else:
            print("‚ùå Keine Ergebnisse!")
            return False
        
        print()
        print("=" * 80)
        print("‚úÖ UDS3 VECTOR BACKEND SETUP ERFOLGREICH")
        print("=" * 80)
        print()
        
        print("ZUSAMMENFASSUNG:")
        print(f"‚Ä¢ ChromaDB Collection: {collection.name}")
        print(f"‚Ä¢ Dokumente: {collection.count()}")
        print(f"‚Ä¢ Embedding-Modell: {embedding_model}")
        print(f"‚Ä¢ Vector Search: Funktioniert ‚úÖ")
        print()
        
        print("N√ÑCHSTE SCHRITTE:")
        print("1. ‚úÖ Vector Backend konfiguriert")
        print("2. üîÑ Hybrid Search testen (Dense + BM25)")
        print("3. üîÑ Staging Phase 1 deployen")
        print("4. üîÑ Ground-Truth Dataset erstellen")
        print("5. üîÑ Evaluation durchf√ºhren")
        
        return True
        
    except ImportError as e:
        print(f"‚ùå Import Error: {e}")
        print()
        print("Fehlende Dependencies:")
        print("  pip install chromadb requests")
        return False
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    result = asyncio.run(setup_vector_backend())
    sys.exit(0 if result else 1)
