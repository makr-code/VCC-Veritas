name: CD - Continuous Deployment

on:
  push:
    branches: [ main ]
    tags:
      - 'v*.*.*'
  release:
    types: [ published ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy'
        required: false
        type: string

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ============================================================================
  # Determine Deployment Environment
  # ============================================================================
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      version: ${{ steps.version.outputs.version }}
      deploy: ${{ steps.check.outputs.deploy }}
      
    steps:
    - name: Determine environment
      id: env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "release" ]; then
          echo "environment=production" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
        fi
        
    - name: Determine version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.version }}" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
          echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        else
          echo "version=latest" >> $GITHUB_OUTPUT
        fi
        
    - name: Check if deployment should proceed
      id: check
      run: |
        # Only deploy on main branch or tags
        if [ "${{ github.ref }}" = "refs/heads/main" ] || [[ "${{ github.ref }}" == refs/tags/* ]]; then
          echo "deploy=true" >> $GITHUB_OUTPUT
        else
          echo "deploy=false" >> $GITHUB_OUTPUT
        fi

  # ============================================================================
  # Build and Push Docker Images
  # ============================================================================
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.deploy == 'true'
    
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract Docker metadata (backend)
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend
        tags: |
          type=ref,event=branch
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=${{ needs.setup.outputs.version }}
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ needs.setup.outputs.version }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}
          
    - name: Extract Docker metadata (frontend)
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
        tags: |
          type=ref,event=branch
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=${{ needs.setup.outputs.version }}
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ needs.setup.outputs.version }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}

  # ============================================================================
  # Deploy to Staging
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.environment == 'staging' && needs.setup.outputs.deploy == 'true'
    environment:
      name: staging
      url: https://staging.veritas.example.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure kubectl
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
      if: secrets.KUBECONFIG_STAGING != ''
      
    - name: Deploy to staging cluster
      run: |
        # Update image tags in Kubernetes manifests
        sed -i "s|IMAGE_TAG|${{ needs.setup.outputs.version }}|g" k8s/staging/*.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/staging/ --namespace=veritas-staging
        
        # Wait for rollout
        kubectl rollout status deployment/veritas-backend -n veritas-staging --timeout=5m
        kubectl rollout status deployment/veritas-frontend -n veritas-staging --timeout=5m
      if: secrets.KUBECONFIG_STAGING != ''
      
    - name: Deploy via Docker Compose (fallback)
      run: |
        # SSH to staging server and deploy
        echo "${{ secrets.STAGING_SSH_KEY }}" > staging_key
        chmod 600 staging_key
        
        ssh -i staging_key -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'EOF'
          cd /opt/veritas
          docker-compose -f docker-compose.staging.yml pull
          docker-compose -f docker-compose.staging.yml up -d
          docker-compose -f docker-compose.staging.yml ps
        EOF
        
        rm staging_key
      if: secrets.STAGING_SSH_KEY != ''
      
    - name: Run smoke tests
      run: |
        # Wait for deployment to be ready
        sleep 30
        
        # Basic health check
        curl -f https://staging.veritas.example.com/health || exit 1
        curl -f https://staging.veritas.example.com/api/health || exit 1
        
        echo "âœ… Staging deployment successful!"
      continue-on-error: true

  # ============================================================================
  # Deploy to Production
  # ============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.environment == 'production' && needs.setup.outputs.deploy == 'true'
    environment:
      name: production
      url: https://veritas.example.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Create deployment notification
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.ref,
            environment: 'production',
            description: 'Deploying version ${{ needs.setup.outputs.version }}',
            auto_merge: false,
            required_contexts: []
          })
          
    - name: Configure kubectl
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
      if: secrets.KUBECONFIG_PRODUCTION != ''
      
    - name: Backup database
      run: |
        # SSH to production server and backup database
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > prod_key
        chmod 600 prod_key
        
        ssh -i prod_key -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          timestamp=$(date +%Y%m%d_%H%M%S)
          docker exec veritas-db pg_dump -U veritas veritas > /backups/veritas_${timestamp}.sql
          gzip /backups/veritas_${timestamp}.sql
          echo "Backup created: veritas_${timestamp}.sql.gz"
        EOF
        
        rm prod_key
      if: secrets.PRODUCTION_SSH_KEY != ''
      continue-on-error: true
      
    - name: Deploy to production cluster
      run: |
        # Update image tags in Kubernetes manifests
        sed -i "s|IMAGE_TAG|${{ needs.setup.outputs.version }}|g" k8s/production/*.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/production/ --namespace=veritas-production
        
        # Wait for rollout
        kubectl rollout status deployment/veritas-backend -n veritas-production --timeout=10m
        kubectl rollout status deployment/veritas-frontend -n veritas-production --timeout=10m
        
        # Verify deployment
        kubectl get pods -n veritas-production
      if: secrets.KUBECONFIG_PRODUCTION != ''
      
    - name: Deploy via Docker Compose (fallback)
      run: |
        # SSH to production server and deploy
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > prod_key
        chmod 600 prod_key
        
        ssh -i prod_key -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          cd /opt/veritas
          
          # Pull new images
          docker-compose -f docker-compose.production.yml pull
          
          # Zero-downtime deployment with rolling update
          docker-compose -f docker-compose.production.yml up -d --no-deps --scale backend=2 backend
          sleep 10
          docker-compose -f docker-compose.production.yml up -d --no-deps --scale backend=1 backend
          
          docker-compose -f docker-compose.production.yml up -d --no-deps frontend
          
          # Show status
          docker-compose -f docker-compose.production.yml ps
        EOF
        
        rm prod_key
      if: secrets.PRODUCTION_SSH_KEY != ''
      
    - name: Run smoke tests
      run: |
        # Wait for deployment to be ready
        sleep 60
        
        # Basic health checks
        curl -f https://veritas.example.com/health || exit 1
        curl -f https://veritas.example.com/api/health || exit 1
        
        # API endpoint test
        response=$(curl -s https://veritas.example.com/api/version)
        echo "API Response: $response"
        
        echo "âœ… Production deployment successful!"
        
    - name: Update deployment status
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const state = '${{ job.status }}' === 'success' ? 'success' : 'failure';
          github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: context.payload.deployment.id,
            state: state,
            environment_url: 'https://veritas.example.com',
            description: state === 'success' ? 
              'Deployment completed successfully' : 
              'Deployment failed'
          })

  # ============================================================================
  # Post-Deployment Tasks
  # ============================================================================
  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [setup, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
    - name: Notify deployment success
      uses: actions/github-script@v7
      with:
        script: |
          const environment = '${{ needs.setup.outputs.environment }}';
          const version = '${{ needs.setup.outputs.version }}';
          
          github.rest.repos.createCommitComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            commit_sha: context.sha,
            body: `ðŸš€ Successfully deployed version ${version} to ${environment}!`
          })
          
    - name: Create release notes
      if: startsWith(github.ref, 'refs/tags/')
      uses: actions/github-script@v7
      with:
        script: |
          const version = '${{ needs.setup.outputs.version }}';
          github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: version,
            name: `Release ${version}`,
            body: `## VERITAS Framework ${version}\n\n### Deployed Components\n- Backend: Latest security and performance improvements\n- Frontend: Updated UI and features\n\n### Changes\nSee commit history for detailed changes.`,
            draft: false,
            prerelease: false
          })
      continue-on-error: true
      
    - name: Clean up old images
      run: |
        echo "ðŸ§¹ Cleanup task - would remove old Docker images here"
        # This would typically clean up old container images from registry
        # to save space and reduce clutter
      continue-on-error: true

  # ============================================================================
  # Rollback (Manual Trigger Only)
  # ============================================================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment != ''
    environment:
      name: ${{ github.event.inputs.environment }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Rollback Kubernetes deployment
      run: |
        mkdir -p $HOME/.kube
        
        if [ "${{ github.event.inputs.environment }}" = "staging" ]; then
          echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > $HOME/.kube/config
          namespace="veritas-staging"
        else
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
          namespace="veritas-production"
        fi
        
        chmod 600 $HOME/.kube/config
        
        # Rollback to previous version
        kubectl rollout undo deployment/veritas-backend -n $namespace
        kubectl rollout undo deployment/veritas-frontend -n $namespace
        
        # Wait for rollout
        kubectl rollout status deployment/veritas-backend -n $namespace --timeout=5m
        kubectl rollout status deployment/veritas-frontend -n $namespace --timeout=5m
        
        echo "âœ… Rollback completed successfully!"
      if: secrets.KUBECONFIG_STAGING != '' || secrets.KUBECONFIG_PRODUCTION != ''
